(function () {
    "use strict"; function Ht() { return typeof PushSubscriptionOptions < "u" && PushSubscriptionOptions.prototype.hasOwnProperty("applicationServerKey") } class U extends Error { constructor(e = "") { super(e), Object.defineProperty(this, "message", { configurable: !0, enumerable: !1, value: e, writable: !0 }), Object.defineProperty(this, "name", { configurable: !0, enumerable: !1, value: this.constructor.name, writable: !0 }), Object.defineProperty(this, "stack", { configurable: !0, enumerable: !1, value: new Error(e).stack, writable: !0 }), Object.setPrototypeOf(this, U.prototype) } } var w = (n => (n[n.Empty = 0] = "Empty", n[n.Malformed = 1] = "Malformed", n[n.EnumOutOfRange = 2] = "EnumOutOfRange", n[n.WrongType = 3] = "WrongType", n))(w || {}); class S extends U { argument; reason; constructor(e, t, i = "") { let s; switch (t) { case 0: s = `Supply a non-empty value to '${e}'.`; break; case 1: s = `The value for '${e}' was malformed.`; break; case 2: s = `The value for '${e}' was out of range of the expected input enum.`; break; case 3: s = `The value for '${e}' was of the wrong type.`; break }i && (s += ` ${i}`), super(s), this.argument = e, this.reason = w[t], Object.setPrototypeOf(this, S.prototype) } } var V = (n => (n.Development = "Development", n.Staging = "Staging", n.Production = "Production", n))(V || {}), D = (n => (n.ServiceWorker = "ServiceWorker", n.Host = "Host", n))(D || {}); const zt = () => "localhost", qt = () => "localhost", bt = () => "160400", Gt = () => !0, Kt = 4001, Jt = 3e3, Yt = 18080, Xt = ["outcomes", "on_focus"]; class k { static getBuildEnv() { return V.Production } static getApiEnv() { return V.Production } static getOrigin() { return v.isBrowser() ? window.location.origin : typeof self < "u" && typeof ServiceWorkerGlobalScope < "u" ? self.location.origin : "Unknown" } static getWindowEnv() { if (typeof self < "u" && typeof ServiceWorkerGlobalScope < "u") return D.ServiceWorker; if (typeof window > "u") throw Error("OneSignalSDK: Unsupported JS runtime!"); return D.Host } static getOneSignalApiUrl(e = k.getApiEnv(), t) { const i = zt(); switch (e) { case V.Development: return k.isTurbineEndpoint(t) ? new URL(`http://${i}:${Yt}/api/v1`) : new URL(`http://${i}:${Jt}/api/v1`); case V.Staging: return new URL(`https://${i}/api/v1`); case V.Production: return new URL("https://onesignal.com/api/v1"); default: throw new S("buildEnv", w.EnumOutOfRange) } } static getOneSignalStaticResourcesUrl() { return new URL("https://media.onesignal.com/web-sdk") } static getOneSignalResourceUrlPath() { const e = k.getBuildEnv(), t = qt(), i = "https", s = Kt; let o; if (e === V.Development) o = `${i}://${t}:${s}`; else if (e === V.Staging) o = `https://${t}`; else if (e === V.Production) o = "https://onesignal.com"; else throw new S("buildEnv", w.EnumOutOfRange); return new URL(`${o}/sdks/web/v16`) } static getOneSignalCssFileName() { const e = "OneSignalSDK.page.styles.css", t = k.getBuildEnv(); if (t === V.Development) return `Dev-${e}`; if (t === V.Staging) return `Staging-${e}`; if (t === V.Production) return e; throw new S("buildEnv", w.EnumOutOfRange) } static isTurbineEndpoint(e) { return e ? Xt.some(t => e.indexOf(t) > -1) : !1 } } function Qt(n) { return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n } var Ce = { exports: {} };/*!
 * Bowser - a browser detector
 * https://github.com/ded/bowser
 * MIT License | (c) Dustin Diaz 2015
 */var Zt = Ce.exports, mt; function ei() { return mt || (mt = 1, function (n) { (function (e, t, i) { n.exports ? n.exports = i() : e[t] = i() })(Zt, "bowser", function () { var e = !0; function t(u) { function p(Ee) { var fe = u.match(Ee); return fe && fe.length > 1 && fe[1] || "" } function m(Ee) { var fe = u.match(Ee); return fe && fe.length > 1 && fe[2] || "" } var y = p(/(ipod|iphone|ipad)/i).toLowerCase(), T = /like android/i.test(u), C = !T && /android/i.test(u), ze = /nexus\s*[0-6]\s*/i.test(u), qe = !ze && /nexus\s*[0-9]+/i.test(u), E = /CrOS/.test(u), W = /silk/i.test(u), ye = /sailfish/i.test(u), Oe = /tizen/i.test(u), $ = /(web|hpw)os/i.test(u), Ft = /windows phone/i.test(u), Hi = !Ft && /windows/i.test(u), zi = !y && !W && /macintosh/i.test(u), qi = !C && !ye && !Oe && !$ && /linux/i.test(u), ht = p(/edge\/(\d+(\.\d+)?)/i), x = p(/version\/(\d+(\.\d+)?)/i), _t = /tablet/i.test(u) && !/tablet pc/i.test(u), $t = !_t && /[^-]mobi/i.test(u), Gi = /xbox/i.test(u), a; /opera/i.test(u) ? a = { name: "Opera", opera: e, version: x || p(/(?:opera|opr|opios)[\s\/](\d+(\.\d+)?)/i) } : /opr\/|opios/i.test(u) ? a = { name: "Opera", opera: e, version: p(/(?:opr|opios)[\s\/](\d+(\.\d+)?)/i) || x } : /SamsungBrowser/i.test(u) ? a = { name: "Samsung Internet for Android", samsungBrowser: e, version: x || p(/(?:SamsungBrowser)[\s\/](\d+(\.\d+)?)/i) } : /coast/i.test(u) ? a = { name: "Opera Coast", coast: e, version: x || p(/(?:coast)[\s\/](\d+(\.\d+)?)/i) } : /yabrowser/i.test(u) ? a = { name: "Yandex Browser", yandexbrowser: e, version: x || p(/(?:yabrowser)[\s\/](\d+(\.\d+)?)/i) } : /ucbrowser/i.test(u) ? a = { name: "UC Browser", ucbrowser: e, version: p(/(?:ucbrowser)[\s\/](\d+(?:\.\d+)+)/i) } : /mxios/i.test(u) ? a = { name: "Maxthon", maxthon: e, version: p(/(?:mxios)[\s\/](\d+(?:\.\d+)+)/i) } : /epiphany/i.test(u) ? a = { name: "Epiphany", epiphany: e, version: p(/(?:epiphany)[\s\/](\d+(?:\.\d+)+)/i) } : /puffin/i.test(u) ? a = { name: "Puffin", puffin: e, version: p(/(?:puffin)[\s\/](\d+(?:\.\d+)?)/i) } : /sleipnir/i.test(u) ? a = { name: "Sleipnir", sleipnir: e, version: p(/(?:sleipnir)[\s\/](\d+(?:\.\d+)+)/i) } : /k-meleon/i.test(u) ? a = { name: "K-Meleon", kMeleon: e, version: p(/(?:k-meleon)[\s\/](\d+(?:\.\d+)+)/i) } : Ft ? (a = { name: "Windows Phone", windowsphone: e }, ht ? (a.msedge = e, a.version = ht) : (a.msie = e, a.version = p(/iemobile\/(\d+(\.\d+)?)/i))) : /msie|trident/i.test(u) ? a = { name: "Internet Explorer", msie: e, version: p(/(?:msie |rv:)(\d+(\.\d+)?)/i) } : E ? a = { name: "Chrome", chromeos: e, chromeBook: e, chrome: e, version: p(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i) } : /chrome.+? edge/i.test(u) ? a = { name: "Microsoft Edge", msedge: e, version: ht } : /vivaldi/i.test(u) ? a = { name: "Vivaldi", vivaldi: e, version: p(/vivaldi\/(\d+(\.\d+)?)/i) || x } : ye ? a = { name: "Sailfish", sailfish: e, version: p(/sailfish\s?browser\/(\d+(\.\d+)?)/i) } : /seamonkey\//i.test(u) ? a = { name: "SeaMonkey", seamonkey: e, version: p(/seamonkey\/(\d+(\.\d+)?)/i) } : /firefox|iceweasel|fxios/i.test(u) ? (a = { name: "Firefox", firefox: e, version: p(/(?:firefox|iceweasel|fxios)[ \/](\d+(\.\d+)?)/i) }, /\((mobile|tablet);[^\)]*rv:[\d\.]+\)/i.test(u) && (a.firefoxos = e)) : W ? a = { name: "Amazon Silk", silk: e, version: p(/silk\/(\d+(\.\d+)?)/i) } : /phantom/i.test(u) ? a = { name: "PhantomJS", phantom: e, version: p(/phantomjs\/(\d+(\.\d+)?)/i) } : /slimerjs/i.test(u) ? a = { name: "SlimerJS", slimer: e, version: p(/slimerjs\/(\d+(\.\d+)?)/i) } : /blackberry|\bbb\d+/i.test(u) || /rim\stablet/i.test(u) ? a = { name: "BlackBerry", blackberry: e, version: x || p(/blackberry[\d]+\/(\d+(\.\d+)?)/i) } : $ ? (a = { name: "WebOS", webos: e, version: x || p(/w(?:eb)?osbrowser\/(\d+(\.\d+)?)/i) }, /touchpad\//i.test(u) && (a.touchpad = e)) : /bada/i.test(u) ? a = { name: "Bada", bada: e, version: p(/dolfin\/(\d+(\.\d+)?)/i) } : Oe ? a = { name: "Tizen", tizen: e, version: p(/(?:tizen\s?)?browser\/(\d+(\.\d+)?)/i) || x } : /qupzilla/i.test(u) ? a = { name: "QupZilla", qupzilla: e, version: p(/(?:qupzilla)[\s\/](\d+(?:\.\d+)+)/i) || x } : /chromium/i.test(u) ? a = { name: "Chromium", chromium: e, version: p(/(?:chromium)[\s\/](\d+(?:\.\d+)?)/i) || x } : /chrome|crios|crmo/i.test(u) ? a = { name: "Chrome", chrome: e, version: p(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i) } : C ? a = { name: "Android", version: x } : /safari|applewebkit/i.test(u) ? (a = { name: "Safari", safari: e }, x && (a.version = x)) : y ? (a = { name: y == "iphone" ? "iPhone" : y == "ipad" ? "iPad" : "iPod" }, x && (a.version = x)) : /googlebot/i.test(u) ? a = { name: "Googlebot", googlebot: e, version: p(/googlebot\/(\d+(\.\d+))/i) || x } : a = { name: p(/^(.*)\/(.*) /), version: m(/^(.*)\/(.*) /) }, !a.msedge && /(apple)?webkit/i.test(u) ? (/(apple)?webkit\/537\.36/i.test(u) ? (a.name = a.name || "Blink", a.blink = e) : (a.name = a.name || "Webkit", a.webkit = e), !a.version && x && (a.version = x)) : !a.opera && /gecko\//i.test(u) && (a.name = a.name || "Gecko", a.gecko = e, a.version = a.version || p(/gecko\/(\d+(\.\d+)?)/i)), !a.windowsphone && !a.msedge && (C || a.silk) ? a.android = e : !a.windowsphone && !a.msedge && y ? (a[y] = e, a.ios = e) : zi ? a.mac = e : Gi ? a.xbox = e : Hi ? a.windows = e : qi && (a.linux = e); function Ki(Ee) { switch (Ee) { case "NT": return "NT"; case "XP": return "XP"; case "NT 5.0": return "2000"; case "NT 5.1": return "XP"; case "NT 5.2": return "2003"; case "NT 6.0": return "Vista"; case "NT 6.1": return "7"; case "NT 6.2": return "8"; case "NT 6.3": return "8.1"; case "NT 10.0": return "10"; default: return } } var M = ""; a.windows ? M = Ki(p(/Windows ((NT|XP)( \d\d?.\d)?)/i)) : a.windowsphone ? M = p(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i) : a.mac ? (M = p(/Mac OS X (\d+([_\.\s]\d+)*)/i), M = M.replace(/[_\s]/g, ".")) : y ? (M = p(/os (\d+([_\s]\d+)*) like mac os x/i), M = M.replace(/[_\s]/g, ".")) : C ? M = p(/android[ \/-](\d+(\.\d+)*)/i) : a.webos ? M = p(/(?:web|hpw)os\/(\d+(\.\d+)*)/i) : a.blackberry ? M = p(/rim\stablet\sos\s(\d+(\.\d+)*)/i) : a.bada ? M = p(/bada\/(\d+(\.\d+)*)/i) : a.tizen && (M = p(/tizen[\/\s](\d+(\.\d+)*)/i)), M && (a.osversion = M); var jt = !a.windows && M.split(".")[0]; return _t || qe || y == "ipad" || C && (jt == 3 || jt >= 4 && !$t) || a.silk ? a.tablet = e : ($t || y == "iphone" || y == "ipod" || C || ze || a.blackberry || a.webos || a.bada) && (a.mobile = e), a.msedge || a.msie && a.version >= 10 || a.yandexbrowser && a.version >= 15 || a.vivaldi && a.version >= 1 || a.chrome && a.version >= 20 || a.samsungBrowser && a.version >= 4 || a.firefox && a.version >= 20 || a.safari && a.version >= 6 || a.opera && a.version >= 10 || a.ios && a.osversion && a.osversion.split(".")[0] >= 6 || a.blackberry && a.version >= 10.1 || a.chromium && a.version >= 20 ? a.a = e : a.msie && a.version < 10 || a.chrome && a.version < 20 || a.firefox && a.version < 20 || a.safari && a.version < 6 || a.opera && a.version < 10 || a.ios && a.osversion && a.osversion.split(".")[0] < 6 || a.chromium && a.version < 20 ? a.c = e : a.x = e, a } var i = t(typeof navigator < "u" && navigator.userAgent || ""); i.test = function (u) { for (var p = 0; p < u.length; ++p) { var m = u[p]; if (typeof m == "string" && m in i) return !0 } return !1 }; function s(u) { return u.split(".").length } function o(u, p) { var m = [], y; if (Array.prototype.map) return Array.prototype.map.call(u, p); for (y = 0; y < u.length; y++)m.push(p(u[y])); return m } function r(u) { for (var p = Math.max(s(u[0]), s(u[1])), m = o(u, function (y) { var T = p - s(y); return y = y + new Array(T + 1).join(".0"), o(y.split("."), function (C) { return new Array(20 - C.length).join("0") + C }).reverse() }); --p >= 0;) { if (m[0][p] > m[1][p]) return 1; if (m[0][p] === m[1][p]) { if (p === 0) return 0 } else return -1 } } function c(u, p, m) { var y = i; typeof p == "string" && (m = p, p = void 0), p === void 0 && (p = !1), m && (y = t(m)); var T = "" + y.version; for (var C in u) if (u.hasOwnProperty(C) && y[C]) { if (typeof u[C] != "string") throw new Error("Browser version in the minVersion map should be a string: " + C + ": " + String(u)); return r([T, u[C]]) < 0 } return p } function g(u, p, m) { return !c(u, p, m) } return i.isUnsupportedBrowser = c, i.compareVersions = r, i.check = g, i._detect = t, i }) }(Ce)), Ce.exports } var ve = ei(); const Ge = Qt(ve); function R() { return { mobile: ve.mobile, tablet: ve.tablet, name: ve.name.toLowerCase(), version: ve.version } } class v { static isBrowser() { return typeof window < "u" } static useSafariLegacyPush() { return this.isBrowser() && window.safari?.pushNotification != null } static useSafariVapidPush() { return R().name == "safari" && Ht() && !this.useSafariLegacyPush() } static version() { return bt() } static get TRADITIONAL_CHINESE_LANGUAGE_TAG() { return ["tw", "hant"] } static get SIMPLIFIED_CHINESE_LANGUAGE_TAG() { return ["cn", "hans"] } static getLanguage() { let e = navigator.language; if (e) { e = e.toLowerCase(); const t = e.split("-"); if (t[0] == "zh") { for (const i of v.TRADITIONAL_CHINESE_LANGUAGE_TAG) if (t.indexOf(i) !== -1) return "zh-Hant"; for (const i of v.SIMPLIFIED_CHINESE_LANGUAGE_TAG) if (t.indexOf(i) !== -1) return "zh-Hans"; return "zh-Hant" } else return t[0].substring(0, 2) } else return "en" } static supportsServiceWorkers() { switch (k.getWindowEnv()) { case D.ServiceWorker: return !0; default: return typeof navigator < "u" && "serviceWorker" in navigator } } } let d = class he { static debug; static trace; static info; static warn; static error; static proxyMethodsCreated; static shouldLog() { try { if (typeof window > "u" || typeof window.localStorage > "u") return !1; const e = window.localStorage.getItem("loglevel"); return !!(e && e.toLowerCase() === "trace") } catch { return !1 } } static setLevel(e) { if (!(typeof window > "u" || typeof window.localStorage > "u")) try { window.localStorage.setItem("loglevel", e), he.proxyMethodsCreated = void 0, he.createProxyMethods() } catch { return } } static createProxyMethods() { if (typeof he.proxyMethodsCreated < "u") return; he.proxyMethodsCreated = !0; const e = { log: "debug", trace: "trace", info: "info", warn: "warn", error: "error" }; for (const t of Object.keys(e)) { const i = typeof console[t] < "u", s = e[t]; i && Gt() ? he[s] = console[t].bind(console) : he[s] = function () { } } } }; d.createProxyMethods(); class Ie { static async getRegistration(e) { try { const t = location.origin + e; return await navigator.serviceWorker.getRegistration(t) } catch (t) { d.warn("[Service Worker Status] Error Checking service worker registration", e, t); return } } static getAvailableServiceWorker(e) { const t = e.active || e.installing || e.waiting; return t || d.warn("Could not find an available ServiceWorker instance!"), t } static waitUntilActive(e) { return new Promise(t => { const i = e.installing || e.waiting; i && i.addEventListener("statechange", () => { d.debug("OneSignal Service Worker state changed:", i.state), e.active && t() }), e.active && t() }) } } var P = (n => (n.WorkerVersion = "GetWorkerVersion", n.Subscribe = "Subscribe", n.SubscribeNew = "SubscribeNew", n.NotificationWillDisplay = "notification.willDisplay", n.NotificationClicked = "notification.clicked", n.NotificationDismissed = "notification.dismissed", n.RedirectPage = "command.redirect", n.SessionUpsert = "os.session.upsert", n.SessionDeactivate = "os.session.deactivate", n.AreYouVisible = "os.page_focused_request", n.AreYouVisibleResponse = "os.page_focused_response", n.SetLogging = "os.set_sw_logging", n))(P || {}); class ti { replies; constructor() { this.replies = {} } addListener(e, t, i) { const s = { callback: t, onceListenerOnly: i }, o = this.replies[e.toString()]; o ? o.push(s) : this.replies[e.toString()] = [s] } findListenersForMessage(e) { return this.replies[e.toString()] || [] } deleteListenerRecords(e) { this.replies[e.toString()] = null } deleteAllListenerRecords() { this.replies = {} } deleteListenerRecord(e, t) { const i = this.replies[e.toString()]; if (i != null) for (let s = i.length - 1; s >= 0; s--)i[s] === t && i.splice(s, 1) } } class wt { context; replies; constructor(e, t = new ti) { this.context = e, this.replies = t } async broadcast(e, t) { if (k.getWindowEnv() !== D.ServiceWorker) return; const i = await self.clients.matchAll({ type: "window", includeUncontrolled: !0 }); for (const s of i) d.debug(`[Worker Messenger] [SW -> Page] Broadcasting '${e.toString()}' to window client ${s.url}.`), s.postMessage({ command: e, payload: t }) } async unicast(e, t, i) { if (k.getWindowEnv() === D.ServiceWorker) if (i) d.debug(`[Worker Messenger] [SW -> Page] Unicasting '${e.toString()}' to window client ${i.url}.`), i.postMessage({ command: e, payload: t }); else throw new S("windowClient", w.Empty); else d.debug(`[Worker Messenger] [Page -> SW] Unicasting '${e.toString()}' to service worker.`), this.directPostMessageToSW(e, t) } async directPostMessageToSW(e, t) { d.debug(`[Worker Messenger] [Page -> SW] Direct command '${e.toString()}' to service worker.`); const i = await this.context?.serviceWorkerManager.getOneSignalRegistration(); if (!i) { d.error("`[Worker Messenger] [Page -> SW] Could not get ServiceWorkerRegistration to postMessage!"); return } const s = Ie.getAvailableServiceWorker(i); if (!s) { d.error("`[Worker Messenger] [Page -> SW] Could not get ServiceWorker to postMessage!"); return } s.postMessage({ command: e, payload: t }) } async listen() { if (!v.supportsServiceWorkers()) return; k.getWindowEnv() === D.ServiceWorker ? (self.addEventListener("message", this.onWorkerMessageReceivedFromPage.bind(this)), d.debug("[Worker Messenger] Service worker is now listening for messages.")) : await this.listenForPage() } async listenForPage() { navigator.serviceWorker.addEventListener("message", this.onPageMessageReceivedFromServiceWorker.bind(this)), d.debug(`(${location.origin}) [Worker Messenger] Page is now listening for messages.`) } onWorkerMessageReceivedFromPage(e) { const t = e.data; if (!t || !t.command) return; const i = this.replies.findListenersForMessage(t.command), s = [], o = []; d.debug("[Worker Messenger] Service worker received message:", e.data); for (const r of i) r.onceListenerOnly && s.push(r), o.push(r); for (let r = s.length - 1; r >= 0; r--) { const c = s[r]; this.replies.deleteListenerRecord(t.command, c) } for (const r of o) r.callback.apply(null, [t.payload]) } onPageMessageReceivedFromServiceWorker(e) { const t = e.data; if (!t || !t.command) return; const i = this.replies.findListenersForMessage(t.command), s = [], o = []; d.debug("[Worker Messenger] Page received message:", e.data); for (const r of i) r.onceListenerOnly && s.push(r), o.push(r); for (let r = s.length - 1; r >= 0; r--) { const c = s[r]; this.replies.deleteListenerRecord(t.command, c) } for (const r of o) r.callback.apply(null, [t.payload]) } on(e, t) { this.replies.addListener(e, t, !1) } once(e, t) { this.replies.addListener(e, t, !0) } off(e) { e ? this.replies.deleteListenerRecords(e) : this.replies.deleteAllListenerRecords() } } const ii = "isOptedOut", si = "isPushNotificationsEnabled", St = "os_pageViews", yt = "requiresPrivacyConsent"; class Ot { static removeLegacySubscriptionOptions() { localStorage.removeItem(ii), localStorage.removeItem(si) } static setConsentRequired(e) { localStorage.setItem(yt, e.toString()) } static getConsentRequired() { return localStorage.getItem(yt) === "true" } static setLocalPageViewCount(e) { localStorage.setItem(St, e.toString()) } static getLocalPageViewCount() { return Number(localStorage.getItem(St)) } } class Ae {
        static SESSION_STORAGE_KEY_NAME = "onesignal-pageview-count"; incrementedPageViewCount = !1; getPageViewCount() { try { const e = sessionStorage.getItem(Ae.SESSION_STORAGE_KEY_NAME), t = e ? parseInt(e) : 0; return isNaN(t) ? 0 : t } catch { return 0 } } setPageViewCount(e) { try { sessionStorage.setItem(Ae.SESSION_STORAGE_KEY_NAME, e.toString()) } catch { } } incrementPageViewCount() {
            if (this.incrementedPageViewCount) return; const e = this.getPageViewCount() + 1, t = this.getLocalPageViewCount() + 1; this.setPageViewCount(e), this.setLocalPageViewCount(t), this.incrementedPageViewCount = !0, d.debug(`Incremented page view count: newCountSingleTab: ${e},
      newCountAccrossTabs: ${t}.`)
        } simulatePageNavigationOrRefresh() { this.incrementedPageViewCount = !1 } isFirstPageView() { return this.getPageViewCount() === 1 } getLocalPageViewCount() { return Ot.getLocalPageViewCount() } setLocalPageViewCount(e) { Ot.setLocalPageViewCount(e) }
    } class Ke { static get STORED_PERMISSION_KEY() { return "storedNotificationPermission" } async getPermissionStatus() { if (!OneSignal.context) throw new U("OneSignal.context is undefined. Make sure to call OneSignal.init() before calling getPermissionStatus()."); return await OneSignal.context.permissionManager.getNotificationPermission(OneSignal.config.safariWebId) } async getNotificationPermission(e) { return v.useSafariLegacyPush() ? Ke.getLegacySafariNotificationPermission(e) : this.getW3cNotificationPermission() } static getLegacySafariNotificationPermission(e) { if (e) return window.safari.pushNotification.permission(e).permission; throw new S("safariWebId", w.Empty) } getW3cNotificationPermission() { return Notification.permission } } class Je extends U { constructor(e = "The asynchronous operation has timed out.") { super(e), this.message = e, Object.setPrototypeOf(this, Je.prototype) } } class b { static contains(e, t) { return e ? e.indexOf(t) !== -1 : !1 } static trimUndefined(e) { for (const t in e) e[t] === void 0 && delete e[t]; return e } static capitalize(e) { return e.charAt(0).toUpperCase() + e.slice(1) } static isNullOrUndefined(e) { return typeof e > "u" || e === null } static valueOrDefault(e, t) { return typeof e > "u" || e === null ? t : e } static stringify(e) { return JSON.stringify(e, (t, i) => typeof i == "function" ? "[Function]" : i, 4) } static encodeHashAsUriComponent(e) { let t = ""; const i = Object.keys(e); for (const s of i) { const o = e[s]; t += `${encodeURIComponent(s)}=${encodeURIComponent(o)}` } return t } static timeoutPromise(e, t) { const i = new Promise((s, o) => { setTimeout(() => { o(new Je) }, t) }); return Promise.race([e, i]) } static getValueOrDefault(e, t) { return e ?? t } static padStart(e, t, i) { let s = e; for (; s.length < t;)s = i + s; return s } static parseVersionString(e) { const t = e.toString().split("."), i = b.padStart(t[0], 2, "0"); let s; return t[1] ? s = b.padStart(t[1], 2, "0") : s = "00", +`${i}.${s}` } static lastParts(e, t, i) { const s = e.split(t), o = Math.max(s.length - i, 0); return s.slice(o).join(t) } static enforceAppId(e) { if (!e) throw new Error("App id cannot be empty") } static enforceAlias(e) { if (!e.label) throw new Error("Alias label cannot be empty"); if (!e.id) throw new Error("Alias id cannot be empty") } static sortArrayOfObjects(e, t, i = !1, s = !0) { const o = s ? e : e.slice(); return o.sort((r, c) => { const g = t(r), u = t(c); return g > u ? i ? -1 : 1 : g < u ? i ? 1 : -1 : 0 }), o } } class Me extends U { status; statusText; constructor(e, t) { super("Registration of a Service Worker failed."), this.status = e, this.statusText = t, Object.setPrototypeOf(this, Me.prototype) } } class vt { } class Ye { _events; constructor() { this._events = {} } on(e, t) { return this._events[e] = this._events[e] || [], this._events[e].push(t), this } once(e, t) { const i = this; function s() { i.off(e, s), t.apply(this, arguments) } return s.listener = t, this.on(e, s), this } off(e, t) { const i = this._events[e]; if (i !== void 0) { for (let s = 0; s < i.length; s += 1)if (i[s] === t || i[s].listener === t) { i.splice(s, 1); break } i.length === 0 && this.removeAllListeners(e) } return this } removeAllListeners(e) { return e ? delete this._events[e] : this._events = {}, this } listeners(e) { try { return this._events[e] } catch { return } } numberOfListeners(e) { const t = this.listeners(e); return t ? t.length : 0 } async emit(...e) { const t = e.shift(); let i = this._events[t]; if (i !== void 0) { i = i.slice(0); const s = i.length; for (let o = 0; o < s; o += 1)await i[o].apply(this, e) } return this } } function Pe(n) { return n?.type !== void 0 && n?.id !== void 0 } class Xe { static isValidUrl(e, t) { if (t && t.allowNull && e === null) return !0; if (t && t.allowEmpty && e == null) return !0; try { const i = new URL(e); return t && t.requireHttps ? i.protocol === "https:" : !0 } catch { return !1 } } static isValidBoolean(e, t) { return t && t.allowNull && e === null ? !0 : e === !0 || e === !1 } static isValidArray(e, t) { return t && t.allowNull && e === null || t && t.allowEmpty && e == null ? !0 : e instanceof Array } } var It = (n => (n.HttpsPermissionRequest = "HTTPS permission request", n.SlidedownPermissionMessage = "slidedown permission message", n.SubscriptionBell = "subscription bell", n))(It || {}), ce = (n => (n[n.MissingAppId = 0] = "MissingAppId", n[n.RedundantPermissionMessage = 1] = "RedundantPermissionMessage", n[n.PushPermissionAlreadyGranted = 2] = "PushPermissionAlreadyGranted", n[n.UnsupportedEnvironment = 3] = "UnsupportedEnvironment", n[n.MissingDomElement = 4] = "MissingDomElement", n[n.ServiceWorkerNotActivated = 5] = "ServiceWorkerNotActivated", n))(ce || {}); class ie extends U { description; reason; constructor(e, t) { let i; switch (e) { case 0: i = "Missing required app ID."; break; case 1: { let s = ""; t && t.permissionPromptType && (s = `(${It[t.permissionPromptType]})`), i = `Another permission message ${s} is being displayed.`; break } case 2: i = "Push permission has already been granted."; break; case 3: i = "The current environment does not support this operation."; break; case 5: i = "The service worker must be activated first."; break }super(i), this.description = ce[e], this.reason = e, Object.setPrototypeOf(this, ie.prototype) } } const se = { Operations: "operations", Identity: "identity", Properties: "properties", Subscriptions: "subscriptions" }, ni = { NORMAL: "NORMAL" }, oi = 7, Ue = { PushSubscriptions: "pushSubscriptions", EmailSubscriptions: "emailSubscriptions", SmsSubscriptions: "smsSubscriptions" }; class ri { constructor(e, t = oi) { this.databaseName = e, this.dbVersion = t, this.emitter = new Ye } emitter; database; openLock; open(e) { return new Promise(t => { let i; try { i = indexedDB.open(e, this.dbVersion) } catch { } if (!i) return null; i.onerror = this.onDatabaseOpenError.bind(this), i.onblocked = this.onDatabaseOpenBlocked.bind(this), i.onupgradeneeded = this.onDatabaseUpgradeNeeded.bind(this), i.onsuccess = () => { this.database = i.result, this.database.onerror = this.onDatabaseError, this.database.onversionchange = this.onDatabaseVersionChange, t(this.database) } }) } async close() { (await this.ensureDatabaseOpen()).close(), this.database?.close() } async ensureDatabaseOpen() { return this.openLock || (this.openLock = this.open(this.databaseName)), await this.openLock } onDatabaseOpenError(e) { e.preventDefault(); const t = e.target.error; b.contains(t.message, "The operation failed for reasons unrelated to the database itself and not covered by any other error code") || b.contains(t.message, "A mutation operation was attempted on a database that did not allow mutations") ? d.warn("OneSignal: IndexedDb web storage is not available on this origin since this profile's IndexedDb schema has been upgraded in a newer version of Firefox. See: https://bugzilla.mozilla.org/show_bug.cgi?id=1236557#c6") : d.warn("OneSignal: Fatal error opening IndexedDb database:", t) } objectStoreNames() { return Array.from(this.database?.objectStoreNames || []) } onDatabaseError(e) { d.debug("IndexedDb: Generic database error", e.target.errorCode) } onDatabaseOpenBlocked() { d.debug("IndexedDb: Blocked event") } onDatabaseVersionChange() { d.debug("IndexedDb: versionchange event") } onDatabaseUpgradeNeeded(e) { d.debug("IndexedDb: Database is being rebuilt or upgraded (upgradeneeded event)."); const t = e.target, i = t.transaction; if (!i) throw Error("Can't migrate DB without a transaction"); const s = t.result, o = e.newVersion || Number.MAX_SAFE_INTEGER; o >= 1 && e.oldVersion < 1 && (s.createObjectStore("Ids", { keyPath: "type" }), s.createObjectStore("NotificationOpened", { keyPath: "url" }), s.createObjectStore("Options", { keyPath: "key" })), o >= 2 && e.oldVersion < 2 && (s.createObjectStore("Sessions", { keyPath: "sessionKey" }), s.createObjectStore("NotificationReceived", { keyPath: "notificationId" }), s.createObjectStore("NotificationClicked", { keyPath: "notificationId" })), o >= 3 && e.oldVersion < 3 && s.createObjectStore("SentUniqueOutcome", { keyPath: "outcomeName" }), o >= 4 && e.oldVersion < 4 && (s.createObjectStore(se.Identity, { keyPath: "modelId" }), s.createObjectStore(se.Properties, { keyPath: "modelId" }), s.createObjectStore(Ue.PushSubscriptions, { keyPath: "modelId" }), s.createObjectStore(Ue.SmsSubscriptions, { keyPath: "modelId" }), s.createObjectStore(Ue.EmailSubscriptions, { keyPath: "modelId" })), o >= 5 && e.oldVersion < 5 && (this.migrateOutcomesNotificationClickedTableForV5(s, i), this.migrateOutcomesNotificationReceivedTableForV5(s, i)), o >= 6 && e.oldVersion < 6 && this.migrateModelNameSubscriptionsTableForV6(s, i), o >= 7 && e.oldVersion < 7 && s.createObjectStore(se.Operations, { keyPath: "modelId" }), typeof OneSignal < "u" && (OneSignal._isNewVisitor = !0) } migrateOutcomesNotificationClickedTableForV5(e, t) { const i = "Outcomes.NotificationClicked"; e.createObjectStore(i, { keyPath: "notificationId" }); const s = "NotificationClicked", o = t.objectStore(s).openCursor(); o.onsuccess = () => { if (!o.result) { e.deleteObjectStore(s); return } const r = o.result.value; t.objectStore(i).put({ notificationId: r.notificationId || r.notification.id, appId: r.appId, timestamp: r.timestamp }), o.result.continue() }, o.onerror = () => { console.error("Could not migrate NotificationClicked records", o.error) } } migrateOutcomesNotificationReceivedTableForV5(e, t) { const i = "Outcomes.NotificationReceived"; e.createObjectStore(i, { keyPath: "notificationId" }); const s = "NotificationReceived", o = t.objectStore(s).openCursor(); o.onsuccess = () => { if (!o.result) { e.deleteObjectStore(s); return } t.objectStore(i).put(o.result.value), o.result.continue() }, o.onerror = () => { console.error("Could not migrate NotificationReceived records", o.error) } } migrateModelNameSubscriptionsTableForV6(e, t) { const i = se.Subscriptions; e.createObjectStore(i, { keyPath: "modelId" }); let s; const o = t.objectStore(se.Identity).openCursor(); o.onsuccess = () => { o.result && (s = o.result.value.externalId) }, o.onerror = () => { console.error("Could not find " + se.Identity + " records", o.error) }, Object.values(Ue).forEach(r => { const c = t.objectStore(r).openCursor(); c.onsuccess = () => { if (!c.result) { e.deleteObjectStore(r); return } const g = c.result.value; t.objectStore(i).put({ ...g, modelName: se.Subscriptions, externalId: s }), c.result.continue() }, c.onerror = () => { console.error("Could not migrate " + r + " records", c.error) } }) } async dbOperation(e, t, i) { const s = await this.ensureDatabaseOpen(); return await new Promise((o, r) => { try { const c = s.transaction(e, t === "get" || t === "getAll" ? "readonly" : "readwrite").objectStore(e), g = t === "getAll" || t === "clear" ? c[t]() : c[t](i); g.onsuccess = () => { o(g.result) }, g.onerror = u => { d.error("Database " + t.toUpperCase() + " Transaction Error:", u), r(u) } } catch (c) { d.error("Database " + t.toUpperCase() + " Error:", c), r(c) } }) } async get(e, t) { return t ? this.dbOperation(e, "get", t) : this.dbOperation(e, "getAll") } async getAll(e) { return this.dbOperation(e, "getAll") } async put(e, t) { return this.dbOperation(e, "put", t) } async remove(e, t) { return t ? this.dbOperation(e, "delete", t) : this.dbOperation(e, "clear") } } class Pt { static toDatabase(e) { const t = e.notification, i = e.result; return { action: i.actionId, badge: t.badgeIcon, buttons: this.toDatabaseButtons(t.actionButtons), content: t.body, data: t.additionalData, heading: t.title, icon: t.icon, id: t.notificationId, image: t.image, rr: t.confirmDelivery, tag: t.topic, timestamp: e.timestamp, url: i.url } } static toDatabaseButtons(e) { return e?.map(t => ({ action: t.actionId, title: t.text, icon: t.icon, url: t.launchURL })) } static fromDatabase(e) { return { result: { actionId: e.action, url: e.url }, notification: { notificationId: e.id, title: e.heading, body: e.content, additionalData: e.data, launchURL: e.url, confirmDelivery: e.rr, icon: e.icon, image: e.image, topic: e.tag, badgeIcon: e.badge, actionButtons: this.toOSNotificationButtons(e.buttons) }, timestamp: e.timestamp } } static toOSNotificationButtons(e) { return e?.map(t => ({ actionId: t.action, text: t.title, icon: t.icon, launchURL: t.url })) } } class kt { static toDatabase(e, t) { return { appId: e, notificationId: t.notification.notificationId, timestamp: t.timestamp } } static fromDatabase(e) { return { appId: e.appId, notificationId: e.notificationId, timestamp: e.timestamp } } } class Nt { static toDatabase(e, t, i) { return { appId: e, notificationId: t.notificationId, timestamp: i } } static fromDatabase(e) { return { appId: e.appId, notificationId: e.notificationId, timestamp: e.timestamp } } } class ai { defaultNotificationUrl; defaultNotificationTitle; lastKnownPushEnabled; lastKnownPushToken; lastKnownPushId; lastKnownOptedIn = !0; pendingNotificationClickEvents } var le = (n => (n.Active = "active", n.Inactive = "inactive", n))(le || {}), De = (n => (n[n.UserCreate = 1] = "UserCreate", n[n.UserNewSession = 2] = "UserNewSession", n[n.VisibilityVisible = 3] = "VisibilityVisible", n[n.VisibilityHidden = 4] = "VisibilityHidden", n[n.BeforeUnload = 5] = "BeforeUnload", n[n.PageRefresh = 6] = "PageRefresh", n[n.Focus = 7] = "Focus", n[n.Blur = 8] = "Blur", n))(De || {}); const Qe = "oneSignalSession"; function xt(n) { const e = new Date().getTime(), t = n && n.notificationId || null; return { accumulatedDuration: 0, appId: n.appId, lastActivatedTimestamp: e, lastDeactivatedTimestamp: null, notificationId: t, sessionKey: Qe, startTimestamp: e, status: "active" } } class Ze { deviceId; subscriptionToken; optedOut; createdAt; expirationTime; serialize() { return { deviceId: this.deviceId, subscriptionToken: this.subscriptionToken, optedOut: this.optedOut, createdAt: this.createdAt, expirationTime: this.expirationTime } } static deserialize(e) { const t = new Ze; return t.deviceId = e.deviceId, t.subscriptionToken = e.subscriptionToken, t.optedOut = e.optedOut, t.createdAt = e.createdAt, t.expirationTime = e.expirationTime, t } } class ci { previousOneSignalId; previousExternalId } var Tt = (n => (n[n.SET = 0] = "SET", n))(Tt || {}); const li = "ONE_SIGNAL_SDK_DB", et = "Outcomes.NotificationClicked", tt = "Outcomes.NotificationReceived", Re = "NotificationOpened", it = "Sessions"; class l { constructor(e) { this.databaseName = e, this.emitter = new Ye, this.database = new ri(this.databaseName) } emitter; database; static databaseInstanceName; static databaseInstance; static EVENTS = Tt; static resetInstance() { l.databaseInstance = null } static get singletonInstance() { return l.databaseInstanceName || (l.databaseInstanceName = li), l.databaseInstance || (l.databaseInstance = new l(l.databaseInstanceName)), l.databaseInstance } static applyDbResultFilter(e, t, i) { switch (e) { case "Options": return i && t ? i.value : i && !t ? i : null; case "Ids": return i && t ? i.id : i && !t ? i : null; default: return i || null } } async get(e, t) { const i = await this.database.get(e, t); return l.applyDbResultFilter(e, t, i) } async getAll(e) { return await this.database.getAll(e) } async put(e, t) { await new Promise(i => { this.database.put(e, t).then(() => i()) }), this.emitter.emit(l.EVENTS.SET, t) } remove(e, t) { return this.database.remove(e, t) } async getAppConfig() { const e = {}, t = await this.get("Ids", "appId"); return e.appId = t, e.vapidPublicKey = await this.get("Options", "vapidPublicKey"), e } async setAppConfig(e) { e.appId && await this.put("Ids", { type: "appId", id: e.appId }), e.vapidPublicKey && await this.put("Options", { key: "vapidPublicKey", value: e.vapidPublicKey }) } async getAppState() { const e = new ai; return e.defaultNotificationUrl = await this.get("Options", "defaultUrl"), e.defaultNotificationTitle = await this.get("Options", "defaultTitle"), e.lastKnownPushEnabled = await this.get("Options", "isPushEnabled"), e.pendingNotificationClickEvents = await this.getAllPendingNotificationClickEvents(), e.lastKnownPushId = await this.get("Options", "lastPushId"), e.lastKnownPushToken = await this.get("Options", "lastPushToken"), e.lastKnownOptedIn = await this.get("Options", "lastOptedIn"), e } async setIsPushEnabled(e) { await this.put("Options", { key: "isPushEnabled", value: e }) } async setAppState(e) { if (e.defaultNotificationUrl && await this.put("Options", { key: "defaultUrl", value: e.defaultNotificationUrl }), (e.defaultNotificationTitle || e.defaultNotificationTitle === "") && await this.put("Options", { key: "defaultTitle", value: e.defaultNotificationTitle }), e.lastKnownPushEnabled != null && await this.setIsPushEnabled(e.lastKnownPushEnabled), e.lastKnownPushId != null && await this.put("Options", { key: "lastPushId", value: e.lastKnownPushId }), e.lastKnownPushToken != null && await this.put("Options", { key: "lastPushToken", value: e.lastKnownPushToken }), e.lastKnownOptedIn != null && await this.put("Options", { key: "lastOptedIn", value: e.lastKnownOptedIn }), e.pendingNotificationClickEvents) { const t = Object.keys(e.pendingNotificationClickEvents); for (const i of t) { const s = e.pendingNotificationClickEvents[i]; s ? await this.put(Re, { url: i, data: s.data, timestamp: s.timestamp }) : s === null && await this.remove(Re, i) } } } async getUserState() { const e = new ci; return e.previousOneSignalId = "", e.previousExternalId = "", e.previousOneSignalId = await this.get("Options", "previousOneSignalId"), e.previousExternalId = await this.get("Options", "previousExternalId"), e } async setUserState(e) { await this.put("Options", { key: "previousOneSignalId", value: e.previousOneSignalId }), await this.put("Options", { key: "previousExternalId", value: e.previousExternalId }) } async getSubscription() { const e = new Ze; e.deviceId = await this.get("Ids", "userId"), e.subscriptionToken = await this.get("Ids", "registrationId"); const t = await this.get("Options", "optedOut"), i = await this.get("Options", "subscription"), s = await this.get("Options", "subscriptionCreatedAt"), o = await this.get("Options", "subscriptionExpirationTime"); return t != null ? e.optedOut = t : i == null ? e.optedOut = !1 : e.optedOut = !i, e.createdAt = s, e.expirationTime = o, e } async setDeviceId(e) { await this.put("Ids", { type: "userId", id: e }) } async setSubscription(e) { e.deviceId && await this.setDeviceId(e.deviceId), typeof e.subscriptionToken < "u" && await this.put("Ids", { type: "registrationId", id: e.subscriptionToken }), e.optedOut != null && await this.put("Options", { key: "optedOut", value: e.optedOut }), e.createdAt != null && await this.put("Options", { key: "subscriptionCreatedAt", value: e.createdAt }), e.expirationTime != null ? await this.put("Options", { key: "subscriptionExpirationTime", value: e.expirationTime }) : await this.remove("Options", "subscriptionExpirationTime") } async setJWTToken(e) { await this.put("Ids", { type: "jwtToken", id: e }) } async getJWTToken() { return await this.get("Ids", "jwtToken") } async setProvideUserConsent(e) { await this.put("Options", { key: "userConsent", value: e }) } async getConsentGiven() { return await this.get("Options", "userConsent") } async getSession(e) { return await this.get(it, e) } async setSession(e) { await this.put(it, e) } async removeSession(e) { await this.remove(it, e) } async getLastNotificationClickedForOutcomes(e) { let t = []; try { t = await this.getAllNotificationClickedForOutcomes() } catch (s) { d.error("Database.getLastNotificationClickedForOutcomes", s) } const i = s => s.appId === e; return t.find(i) || null } async getAllNotificationClickedForOutcomes() { return (await this.getAll(et)).map(t => kt.fromDatabase(t)) } async putNotificationClickedForOutcomes(e, t) { await this.put(et, kt.toDatabase(e, t)) } async putNotificationClickedEventPendingUrlOpening(e) { await this.put(Re, Pt.toDatabase(e)) } async getAllPendingNotificationClickEvents() { const e = {}, t = await this.getAll(Re); for (const i of t) { const s = Pt.fromDatabase(i), o = s.result.url; o && (e[o] = s) } return e } async removeAllNotificationClickedForOutcomes() { await this.remove(et) } async getAllNotificationReceivedForOutcomes() { return (await this.getAll(tt)).map(t => Nt.fromDatabase(t)) } async putNotificationReceivedForOutcomes(e, t) { await this.put(tt, Nt.toDatabase(e, t, new Date().getTime())) } async resetSentUniqueOutcomes() { const t = (await this.getAll("SentUniqueOutcome")).map(i => (i.sentDuringSession = null, l.put("SentUniqueOutcome", i))); await Promise.all(t) } static async clear() { const e = await l.singletonInstance.database.objectStoreNames(); for (const t of e) await l.singletonInstance.database.remove(t) } static async on(...e) { return l.singletonInstance.emitter.on.apply(l.singletonInstance.emitter, e) } static async getPushId() { return this.get("Options", "lastPushId") } static async setPushId(e) { await this.put("Options", { key: "lastPushId", value: e }) } static async getPushToken() { return this.get("Options", "lastPushToken") } static async setPushToken(e) { await this.put("Options", { key: "lastPushToken", value: e }) } static async setIsPushEnabled(e) { return l.singletonInstance.setIsPushEnabled(e) } static async getCurrentSession() { return await l.singletonInstance.getSession(Qe) } static async upsertSession(e) { await l.singletonInstance.setSession(e) } static async cleanupCurrentSession() { await l.singletonInstance.removeSession(Qe) } static async setSubscription(e) { return await l.singletonInstance.setSubscription(e) } static async getSubscription() { return await l.singletonInstance.getSubscription() } static async setJWTToken(e) { return await l.singletonInstance.setJWTToken(e) } static async getJWTToken() { return await l.singletonInstance.getJWTToken() } static async setConsentGiven(e) { return await l.singletonInstance.setProvideUserConsent(e) } static async getConsentGiven() { return await l.singletonInstance.getConsentGiven() } static async setAppState(e) { return await l.singletonInstance.setAppState(e) } static async getAppState() { return await l.singletonInstance.getAppState() } static async setUserState(e) { return await l.singletonInstance.setUserState(e) } static async getUserState() { return await l.singletonInstance.getUserState() } static async setAppConfig(e) { return await l.singletonInstance.setAppConfig(e) } static async getAppConfig() { return await l.singletonInstance.getAppConfig() } static async getLastNotificationClickedForOutcomes(e) { return await l.singletonInstance.getLastNotificationClickedForOutcomes(e) } static async removeAllNotificationClickedForOutcomes() { return await l.singletonInstance.removeAllNotificationClickedForOutcomes() } static async getAllNotificationReceivedForOutcomes() { return await l.singletonInstance.getAllNotificationReceivedForOutcomes() } static async putNotificationReceivedForOutcomes(e, t) { return await l.singletonInstance.putNotificationReceivedForOutcomes(e, t) } static async getAllNotificationClickedForOutcomes() { return await l.singletonInstance.getAllNotificationClickedForOutcomes() } static async putNotificationClickedForOutcomes(e, t) { return await l.singletonInstance.putNotificationClickedForOutcomes(e, t) } static async putNotificationClickedEventPendingUrlOpening(e) { return await l.singletonInstance.putNotificationClickedEventPendingUrlOpening(e) } static async resetSentUniqueOutcomes() { return await l.singletonInstance.resetSentUniqueOutcomes() } static async setDeviceId(e) { await l.singletonInstance.setDeviceId(e) } static async remove(e, t) { return await l.singletonInstance.remove(e, t) } static async put(e, t) { return await l.singletonInstance.put(e, t) } static async get(e, t) { return await l.singletonInstance.get(e, t) } static async getAll(e) { return await l.singletonInstance.getAll(e) } } class j { static getBaseUrl() { return location.origin } static redetectBrowserUserAgent() { return R().name === "" && R().version === "" ? Ge._detect(navigator.userAgent) : Ge } static isValidUuid(e) { return /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/.test(e) } static getRandomUuid() { const e = typeof window > "u" ? global.crypto : window.crypto || window.msCrypto; return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (i) { const s = e.getRandomValues(new Uint8Array(1))[0] % 16 | 0; return (i == "x" ? s : s & 3 | 8).toString(16) }) } static logMethodCall(e, ...t) { return d.debug(`Called ${e}(${t.map(b.stringify).join(", ")})`) } static isSafari() { return v.isBrowser() && typeof window.safari < "u" } } const ui = ["notifyButtonHovering", "notifyButtonHover", "notifyButtonButtonClick", "notifyButtonLauncherClick", "animatedElementHiding", "animatedElementHidden", "animatedElementShowing", "animatedElementShown", "activeAnimatedElementActivating", "activeAnimatedElementActive", "activeAnimatedElementInactivating", "activeAnimatedElementInactive"]; class H { static async trigger(e, t, i) { if (!b.contains(ui, e)) { const s = t, o = b.capitalize(k.getWindowEnv().toString()); s || s === !1 ? d.debug(`(${o}) Â» ${e}:`, s) : d.debug(`(${o}) Â» ${e}`) } if (v.isBrowser()) { if (e === OneSignal.EVENTS.SDK_INITIALIZED) { if (OneSignal.initialized) return; OneSignal.initialized = !0 } i ? await i.emit(e, t) : await OneSignal.emitter.emit(e, t) } } } class ne { static executing = !1; static async triggerNotificationPermissionChanged(e = !1) { if (!ne.executing) { ne.executing = !0; try { await ne.privateTriggerNotificationPermissionChanged(e) } finally { ne.executing = !1 } } } static async privateTriggerNotificationPermissionChanged(e) { const t = await OneSignal.context.permissionManager.getPermissionStatus(), i = await l.get("Options", "notificationPermission"); (t !== i || e) && (await l.put("Options", { key: "notificationPermission", value: t }), H.trigger(OneSignal.EVENTS.NOTIFICATION_PERMISSION_CHANGED_AS_STRING, t), this.triggerBooleanPermissionChangeEvent(i, t, e)) } static triggerBooleanPermissionChangeEvent(e, t, i) { const s = t === "granted"; (s !== (e === "granted") || i) && H.trigger(OneSignal.EVENTS.NOTIFICATION_PERMISSION_CHANGED_AS_BOOLEAN, s) } } async function ke() { return new Promise(n => { OneSignal.initialized ? n() : OneSignal.emitter.once(OneSignal.EVENTS.SDK_INITIALIZED, n) }) } function di(n, ...e) { if (n) return n.apply(null, e) } function I(n, ...e) { return j.logMethodCall(n, ...e) } function pi(n) { return !!n && !!n.match(/^([^\x00-\x20\x22\x28\x29\x2c\x2e\x3a-\x3c\x3e\x40\x5b-\x5d\x7f-\xff]+|\x22([^\x0d\x22\x5c\x80-\xff]|\x5c[\x00-\x7f])*\x22)(\x2e([^\x00-\x20\x22\x28\x29\x2c\x2e\x3a-\x3c\x3e\x40\x5b-\x5d\x7f-\xff]+|\x22([^\x0d\x22\x5c\x80-\xff]|\x5c[\x00-\x7f])*\x22))*\x40([^\x00-\x20\x22\x28\x29\x2c\x2e\x3a-\x3c\x3e\x40\x5b-\x5d\x7f-\xff]+|\x5b([^\x0d\x5b-\x5d\x80-\xff]|\x5c[\x00-\x7f])*\x5d)(\x2e([^\x00-\x20\x22\x28\x29\x2c\x2e\x3a-\x3c\x3e\x40\x5b-\x5d\x7f-\xff]+|\x5b([^\x0d\x5b-\x5d\x80-\xff]|\x5c[\x00-\x7f])*\x5d))*$/) } function B(n, e) { if (typeof n == "string") { const t = document.querySelector(n); if (t === null) throw new Error(`Cannot find element with selector "${n}"`); t.classList.add(e) } else if (typeof n == "object") n.classList.add(e); else throw new Error(`${n} must be a CSS selector string or DOM Element object.`) } function st(n) { return j.isValidUuid(n) } function gi(n) { return n ? R().name == "safari" && n.safari ? n.safari : R().name === "firefox" && n.firefox ? n.firefox : n.chrome || n.firefox || n.safari || "default-icon" : "default-icon" } function nt(n) { return JSON.parse(JSON.stringify(n)) } class Et extends vt { _id; _token; _optedIn; _permission; constructor(e, t, i) { if (super(), !e || !t) { d.warn(`PushSubscriptionNamespace: skipping initialization. One or more required params are falsy: initialize: ${e}, subscription: ${t}`); return } this._optedIn = !t.optedOut, this._permission = i, this._token = t.subscriptionToken, OneSignal.coreDirector.getPushSubscriptionModel().then(s => { Pe(s) && (this._id = s.id) }).catch(s => { d.error(s) }), OneSignal.emitter.on(OneSignal.EVENTS.SUBSCRIPTION_CHANGED, async s => { this._id = s?.current.id, this._token = s?.current.token }), OneSignal.emitter.on(OneSignal.EVENTS.NOTIFICATION_PERMISSION_CHANGED_AS_STRING, async s => { this._permission = s }) } get id() { return this._id } get token() { return this._token } get optedIn() { return !!this._optedIn && this._permission === "granted" } async optIn() { if (I("optIn"), await ke(), this._optedIn = !0, await OneSignal.context.permissionManager.getPermissionStatus() !== "granted") { await OneSignal.Notifications.requestPermission(); return } await this._enable(!0) } async optOut() { I("optOut"), await ke(), this._optedIn = !1, await this._enable(!1) } addEventListener(e, t) { OneSignal.emitter.on(e, t) } removeEventListener(e, t) { OneSignal.emitter.off(e, t) } async _enable(e) { await ke(); const t = await l.getAppConfig(), i = await l.getSubscription(); if (!t.appId) throw new ie(ce.MissingAppId); if (!Xe.isValidBoolean(e)) throw new S("enabled", w.Malformed); i.optedOut = !e, await l.setSubscription(i), _.onInternalSubscriptionSet(i.optedOut).catch(s => { d.error(s) }), _.checkAndTriggerSubscriptionChanged().catch(s => { d.error(s) }) } } const Q = { ChromePush: "ChromePush", Email: "Email", SMS: "SMS", SafariPush: "SafariPush", SafariLegacyPush: "SafariLegacyPush", FirefoxPush: "FirefoxPush" }, F = { NoNativePermission: 0, Subscribed: 1, UserOptedOut: -2, TemporaryWebRecord: -20, PermissionRevoked: -21, PushSubscriptionRevoked: -22, ServiceWorkerStatus403: -23, ServiceWorkerStatus404: -24 }; var Ne = (n => (n[n.ChromeLike = 5] = "ChromeLike", n[n.SafariLegacy = 7] = "SafariLegacy", n[n.Firefox = 8] = "Firefox", n[n.Email = 11] = "Email", n[n.Edge = 12] = "Edge", n[n.SMS = 14] = "SMS", n[n.SafariVapid = 17] = "SafariVapid", n))(Ne || {}), ue = (n => (n.Safari = "safari", n.Firefox = "firefox", n.Chrome = "chrome", n.Opera = "opera", n.Edge = "edge", n.Other = "other", n))(ue || {}); class fi { static getEnvironmentInfo() { return { browserType: this.getBrowser(), browserVersion: this.getBrowserVersion(), isBrowserAndSupportsServiceWorkers: this.supportsServiceWorkers(), requiresUserInteraction: this.requiresUserInteraction(), osVersion: this.getOsVersion() } } static getBrowser() { return R().name === "chrome" ? ue.Chrome : R().name === "msedge" ? ue.Edge : R().name === "opera" ? ue.Opera : R().name === "firefox" ? ue.Firefox : this.isMacOSSafari() ? ue.Safari : ue.Other } static isMacOSSafari() { return typeof window.safari < "u" } static getBrowserVersion() { return b.parseVersionString(R().version) } static supportsServiceWorkers() { return window.navigator && "serviceWorker" in window.navigator } static requiresUserInteraction() { return this.getBrowser() === "firefox" && this.getBrowserVersion() >= 72 || this.getBrowser() === "safari" && this.getBrowserVersion() >= 12.1 } static getOsVersion() { return Ge.osversion } } class N { type; token; enabled; notificationTypes; sdk; deviceModel; deviceOs; webAuth; webp256; constructor(e) { this.token = this._getToken(e), this.type = N.getSubscriptionType(), this.enabled = !0, this.notificationTypes = F.Subscribed, this.sdk = N.getSdk(), this.deviceModel = N.getDeviceModel(), this.deviceOs = N.getDeviceOS(), this.webAuth = e.w3cAuth, this.webp256 = e.w3cP256dh } _getToken(e) { return e.w3cEndpoint ? e.w3cEndpoint.toString() : e.safariDeviceToken } serialize() { return { type: this.type, token: this.token, enabled: this.enabled, notification_types: this.notificationTypes, sdk: this.sdk, device_model: this.deviceModel, device_os: this.deviceOs, web_auth: this.webAuth, web_p256: this.webp256 } } static getSubscriptionType() { return j.redetectBrowserUserAgent().firefox ? Q.FirefoxPush : v.useSafariVapidPush() ? Q.SafariPush : v.useSafariLegacyPush() ? Q.SafariLegacyPush : Q.ChromePush } static getDeviceType() { switch (this.getSubscriptionType()) { case Q.FirefoxPush: return Ne.Firefox; case Q.SafariLegacyPush: return Ne.SafariLegacy; case Q.SafariPush: return Ne.SafariVapid }return Ne.ChromeLike } static getDeviceOS() { const e = fi.getEnvironmentInfo(); return isNaN(e.browserVersion) ? -1 : e.browserVersion } static getDeviceModel() { return navigator.platform } static getSdk() { return String(bt()) } } class hi { subscribers = []; get hasSubscribers() { return this.subscribers.length > 0 } subscribe(e) { this.subscribers.push(e) } unsubscribe(e) { const t = this.subscribers.indexOf(e); t !== -1 && this.subscribers.splice(t, 1) } subscribeAll(e) { for (const t of e.subscribers) this.subscribe(t) } fire(e) { for (const t of this.subscribers) e(t) } async suspendingFire(e) { for (const t of this.subscribers) await e(t) } } class Le { modelId; data = new Map; changeNotifier = new hi; constructor() { this.modelId = Math.random().toString(36).substring(2) } initializeFromJson(e) { const { modelId: t, modelName: i, ...s } = e; this.data.clear(), this.data = new Map(Object.entries(s)), t && (this.modelId = t) } initializeFromModel(e, t) { const i = new Map; t.data.forEach((s, o) => { i.set(o, s) }), e !== null && (this.modelId = e), this.data.clear(), this.data = i } setProperty(e, t, i = ni.NORMAL, s = !1) { const o = this.data.get(e); o === t && !s || (t !== void 0 ? this.data.set(e, t) : this.data.has(e) && this.data.delete(e), this.notifyChanged(e, i, o, t)) } hasProperty(e) { return this.data.has(e) } getProperty(e, t) { return this.data.get(e) ?? t } notifyChanged(e, t, i, s) { const o = { model: this, property: e, oldValue: i, newValue: s }; this.changeNotifier.fire(r => r.onChanged(o, t)) } toJSON() { return Object.fromEntries(this.data.entries()) } subscribe(e) { return this.changeNotifier.subscribe(e) } unsubscribe(e) { this.changeNotifier.unsubscribe(e) } get hasSubscribers() { return this.changeNotifier.hasSubscribers } mergeData(e) { for (const [t, i] of Object.entries(e)) this.data.set(t, i) } } class bi extends Le { constructor() { super(), this.sdk = N.getSdk(), this.device_model = N.getDeviceModel(), this.device_os = N.getDeviceOS() } get onesignalId() { return this.getProperty("onesignalId") } set onesignalId(e) { this.setProperty("onesignalId", e) } get id() { return this.getProperty("id") } set id(e) { this.setProperty("id", e) } get enabled() { return this.getProperty("enabled") } set enabled(e) { this.setProperty("enabled", e) } get type() { return this.getProperty("type") } set type(e) { this.setProperty("type", e) } get token() { return this.getProperty("token") } set token(e) { this.setProperty("token", e) } get notification_types() { return this.getProperty("notification_types") } set notification_types(e) { this.setProperty("notification_types", e) } get sdk() { return this.getProperty("sdk") } set sdk(e) { this.setProperty("sdk", e) } get device_model() { return this.getProperty("device_model") } set device_model(e) { this.setProperty("device_model", e) } get device_os() { return this.getProperty("device_os") } set device_os(e) { this.setProperty("device_os", e) } get web_auth() { return this.getProperty("web_auth") } set web_auth(e) { this.setProperty("web_auth", e) } get web_p256() { return this.getProperty("web_p256") } set web_p256(e) { this.setProperty("web_p256", e) } } const Z = { LOCAL_PREFIX: "local-", createLocalId() { return `${this.LOCAL_PREFIX}${crypto.randomUUID()}` }, isLocalId(n) { return n?.startsWith(this.LOCAL_PREFIX) ?? !1 } }; class q { isCreatingUser = !1; static singletonInstance = void 0; static createOrGetInstance() { return q.singletonInstance || (q.singletonInstance = new q), q.singletonInstance } get onesignalId() { const e = OneSignal.coreDirector.getIdentityModel().onesignalId; return Z.isLocalId(e) ? void 0 : e } addAlias(e, t) { if (I("addAlias", { label: e, id: t }), typeof e != "string") throw new S("label", w.WrongType); if (typeof t != "string") throw new S("id", w.WrongType); if (!e) throw new S("label", w.Empty); if (!t) throw new S("id", w.Empty); this.addAliases({ [e]: t }) } addAliases(e) { if (I("addAliases", { aliases: e }), !e || Object.keys(e).length === 0) throw new S("aliases", w.Empty); Object.keys(e).forEach(async i => { if (typeof i != "string") throw new S("label", w.WrongType) }); const t = OneSignal.coreDirector.getIdentityModel(); Object.keys(e).forEach(async i => { t.setProperty(i, e[i]) }) } removeAlias(e) { if (I("removeAlias", { label: e }), typeof e != "string") throw new S("label", w.WrongType); if (!e) throw new S("label", w.Empty); this.removeAliases([e]) } removeAliases(e) { if (I("removeAliases", { aliases: e }), !e || e.length === 0) throw new S("aliases", w.Empty); const t = OneSignal.coreDirector.getIdentityModel(); e.forEach(async i => { t.setProperty(i, void 0) }) } addSubscriptionToModels({ type: e, token: t }) { if (OneSignal.coreDirector.subscriptionModelStore.list().find(r => r.token === t && r.type === e)) return; const s = { id: Z.createLocalId(), enabled: !0, notification_types: F.Subscribed, onesignalId: OneSignal.coreDirector.getIdentityModel().onesignalId, token: t, type: e }, o = new bi; o.mergeData(s), OneSignal.coreDirector.addSubscriptionModel(o) } async addEmail(e) { if (I("addEmail", { email: e }), typeof e != "string") throw new S("email", w.WrongType); if (!e) throw new S("email", w.Empty); if (!pi(e)) throw new S("email", w.Malformed); this.addSubscriptionToModels({ type: Q.Email, token: e }) } async addSms(e) { if (I("addSms", { sms: e }), typeof e != "string") throw new S("sms", w.WrongType); if (!e) throw new S("sms", w.Empty); this.addSubscriptionToModels({ type: Q.SMS, token: e }) } removeEmail(e) { if (I("removeEmail", { email: e }), typeof e != "string") throw new S("email", w.WrongType); if (!e) throw new S("email", w.Empty); OneSignal.coreDirector.getEmailSubscriptionModels().forEach(i => { i.token === e && OneSignal.coreDirector.removeSubscriptionModel(i.modelId) }) } removeSms(e) { if (I("removeSms", { smsNumber: e }), typeof e != "string") throw new S("smsNumber", w.WrongType); if (!e) throw new S("smsNumber", w.Empty); OneSignal.coreDirector.getSmsSubscriptionModels().forEach(i => { i.token === e && OneSignal.coreDirector.removeSubscriptionModel(i.modelId) }) } addTag(e, t) { if (I("addTag", { key: e, value: t }), typeof e != "string") throw new S("key", w.WrongType); if (typeof t != "string") throw new S("value", w.WrongType); if (!e) throw new S("key", w.Empty); if (!t) throw new S("value", w.Empty, "Did you mean to call removeTag?"); this.addTags({ [e]: t }) } addTags(e) { if (I("addTags", { tags: e }), typeof e != "object") throw new S("tags", w.WrongType); if (!e) throw new S("tags", w.Empty); const t = OneSignal.coreDirector.getPropertiesModel(), i = { ...t.tags, ...e }; t.tags = i } removeTag(e) { if (I("removeTag", { tagKey: e }), typeof e != "string") throw new S("tagKey", w.WrongType); if (!e) throw new S("tagKey", w.Empty); this.removeTags([e]) } removeTags(e) { if (I("removeTags", { tagKeys: e }), !e || e.length === 0) throw new S("tagKeys", w.Empty); const t = OneSignal.coreDirector.getPropertiesModel(), i = { ...t.tags }; e.forEach(s => { i[s] = "" }), t.tags = i } getTags() { return I("getTags"), OneSignal.coreDirector.getPropertiesModel().tags } setLanguage(e) { if (I("setLanguage", { language: e }), typeof e != "string") throw new S("language", w.WrongType); if (!e) throw new S("language", w.Empty); const t = OneSignal.coreDirector.getPropertiesModel(); t.language = e } getLanguage() { return I("getLanguage"), OneSignal.coreDirector.getPropertiesModel().language } } class We extends vt { _currentUser; PushSubscription = new Et(!1); static emitter = new Ye; constructor(e, t, i) { super(), e && (this._currentUser = q.createOrGetInstance(), this.PushSubscription = new Et(!0, t, i)) } get onesignalId() { return this._currentUser?.onesignalId } get externalId() { return OneSignal.coreDirector.getIdentityModel()?.externalId } addAlias(e, t) { this._currentUser?.addAlias(e, t) } addAliases(e) { this._currentUser?.addAliases(e) } removeAlias(e) { this._currentUser?.removeAlias(e) } removeAliases(e) { this._currentUser?.removeAliases(e) } addEmail(e) { this._currentUser?.addEmail(e) } removeEmail(e) { this._currentUser?.removeEmail(e) } addSms(e) { this._currentUser?.addSms(e) } removeSms(e) { this._currentUser?.removeSms(e) } addTag(e, t) { this._currentUser?.addTag(e, t) } addTags(e) { this._currentUser?.addTags(e) } removeTag(e) { this._currentUser?.removeTag(e) } removeTags(e) { this._currentUser?.removeTags(e) } getTags() { return this._currentUser?.getTags() || {} } setLanguage(e) { this._currentUser?.setLanguage(e) } getLanguage() { return this._currentUser?.getLanguage() || "" } addEventListener(e, t) { We.emitter.on(e, t) } removeEventListener(e, t) { We.emitter.off(e, t) } } var Ct = (n => (n[n.Loaded = 0] = "Loaded", n[n.Failed = 1] = "Failed", n))(Ct || {}); const G = { containerClass: "onesignal-customlink-container", subscribeClass: "onesignal-customlink-subscribe", explanationClass: "onesignal-customlink-explanation", resetClass: "onesignal-reset", hide: "hide", state: { subscribed: "state-subscribed", unsubscribed: "state-unsubscribed" } }, mi = { containerSelector: `.${G.containerClass}` }; class wi { config; constructor(e) { this.config = e } async initialize() { if (!this.config?.enabled || !await this.loadSdkStyles()) return; d.info("OneSignal: initializing customlink"); const e = await OneSignal.context.subscriptionManager.isPushNotificationsEnabled(); if (!this.config?.unsubscribeEnabled && e) { this.hideCustomLinkContainers(); return } for (let t = 0; t < this.customlinkContainerElements.length; t++)await this.injectMarkup(this.customlinkContainerElements[t]) } async injectMarkup(e) { e.innerHTML = "", await this.mountExplanationNode(e), await this.mountSubscriptionNode(e) } async mountExplanationNode(e) { if (!this.config?.text) { d.error("CustomLink: required property 'text' is missing in the config"); return } if (this.config.text.explanation) { const t = document.createElement("p"); t.textContent = this.config.text.explanation, B(t, G.resetClass), B(t, G.explanationClass), this.config.size && B(t, this.config.size), await OneSignal.context.subscriptionManager.isPushNotificationsEnabled() ? B(t, G.state.subscribed) : B(t, G.state.unsubscribed), e.appendChild(t) } } async mountSubscriptionNode(e) { if (!this.config?.text) { d.error("CustomLink: required property 'text' is missing in the config"); return } if (this.config.text.subscribe) { const t = document.createElement("button"); B(t, G.resetClass), B(t, G.subscribeClass), this.config.size && B(t, this.config.size), this.config.style && B(t, this.config.style), await OneSignal.context.subscriptionManager.isPushNotificationsEnabled() ? B(t, G.state.subscribed) : B(t, G.state.unsubscribed), this.setCustomColors(t), await this.setTextFromPushStatus(t), t.addEventListener("click", async () => { d.info("CustomLink: subscribe clicked"), await this.handleClick(t) }), t.setAttribute("type", "button"), e.appendChild(t) } } async loadSdkStyles() { return await OneSignal.context.dynamicResourceLoader.loadSdkStylesheet() !== Ct.Loaded ? (d.debug("Not initializing custom link button because styles failed to load."), !1) : !0 } hideElement(e) { B(e, G.hide) } hideCustomLinkContainers() { this.customlinkContainerElements.forEach(e => { this.hideElement(e) }) } async handleClick(e) { if (OneSignal.User.PushSubscription.optedIn) await OneSignal.User.PushSubscription.optOut(), await this.setTextFromPushStatus(e); else { await OneSignal.User.PushSubscription.optIn(), this.config?.unsubscribeEnabled || this.hideCustomLinkContainers(); return } } async setTextFromPushStatus(e) { this.config?.text?.subscribe && (await OneSignal.context.subscriptionManager.isPushNotificationsEnabled() || (e.textContent = this.config.text.subscribe)), this.config?.text?.unsubscribe && await OneSignal.context.subscriptionManager.isPushNotificationsEnabled() && (e.textContent = this.config.text.unsubscribe) } setCustomColors(e) { !this.config?.color || !this.config.color.text || (this.config?.style === "button" && this.config?.color.button ? (e.style.backgroundColor = this.config?.color.button, e.style.color = this.config?.color.text) : this.config?.style === "link" && (e.style.color = this.config?.color.text)) } get customlinkContainerElements() { const e = document.querySelectorAll(mi.containerSelector); return Array.prototype.slice.call(e) } } class A { static store = {}; static LIMIT = 2; static put(e, t) { return A.store[e] === void 0 && (A.store[e] = [null, null]), A.store[e].push(t), A.store[e].length == A.LIMIT + 1 && A.store[e].shift(), A.store[e] } static get(e) { return A.store[e] === void 0 && (A.store[e] = [null, null]), A.store[e] } static getFirst(e) { return A.get(e)[0] } static getLast(e) { return A.get(e)[1] } static remove(e) { delete A.store[e] } static isEmpty(e) { const t = A.get(e); return t[0] === null && t[1] === null } } class At { static decodeHtmlEntities(e) { return typeof DOMParser > "u" ? e : new DOMParser().parseFromString(e, "text/html").documentElement.textContent || "" } } var ot = (n => (n[n.Unknown = 0] = "Unknown", n[n.NoDeviceId = 1] = "NoDeviceId", n[n.NoEmailSet = 2] = "NoEmailSet", n[n.NoSMSSet = 3] = "NoSMSSet", n[n.OptedOut = 4] = "OptedOut", n))(ot || {}); class rt extends U { reason; constructor(e) { let t; switch (e) { case 1: t = "This operation can only be performed after the user is subscribed."; break; case 2: t = "No email is currently set."; break; case 3: t = "No sms is currently set."; break; case 4: t = "The user has manually opted out of receiving of notifications. This operation can only be performed after the user is fully resubscribed."; break }super(t), this.reason = ot[e], Object.setPrototypeOf(this, rt.prototype) } } class ee { static async showLocalNotification(e, t, i, s, o, r) { if (I("MainHelper:showLocalNotification: ", e, t, i, s, o, r), !(await l.getAppConfig()).appId) throw new ie(ce.MissingAppId); if (!OneSignal.Notifications.permission) throw new rt(ot.NoDeviceId); if (!Xe.isValidUrl(i)) throw new S("url", w.Malformed); if (!Xe.isValidUrl(s, { allowEmpty: !0, requireHttps: !0 })) throw new S("icon", w.Malformed); if (!s) { const p = await ee.getNotificationIcons(); s = gi(p) } const g = p => { const m = []; for (let y = 0; y < p.length; y++) { const T = p[y]; m.push({ action: T.id, title: T.text, icon: T.icon, url: T.url }) } return m }, u = { data: o, launchURL: i, buttons: r ? g(r) : void 0 }; OneSignal.context.serviceWorkerManager.getRegistration().then(async p => { if (!p) { d.error("Service worker registration not available."); return } const m = { body: t, data: u, icon: s, actions: r ? g(r) : [] }; p.showNotification(e, m) }) } static async checkAndTriggerNotificationPermissionChanged() { const e = await l.get("Options", "notificationPermission"), t = await OneSignal.context.permissionManager.getPermissionStatus(); e !== t && (await ne.triggerNotificationPermissionChanged(), await l.put("Options", { key: "notificationPermission", value: t })) } static async getNotificationIcons() { const e = ee.getAppId(); if (!e) throw new ie(ce.MissingAppId); const t = `${k.getOneSignalApiUrl().toString()}/apps/${e}/icon`, s = await (await fetch(t)).json(); if (s.errors) throw d.error(`API call ${t}`, "failed with:", s.errors), new Error("Failed to get notification icons."); return s } static getSlidedownOptions(e) { return b.getValueOrDefault(e.slidedown, { prompts: [] }) } static getFullscreenPermissionMessageOptions(e) { return e ? e.fullscreen ? { autoAcceptTitle: e.fullscreen.autoAcceptTitle, actionMessage: e.fullscreen.actionMessage, exampleNotificationTitleDesktop: e.fullscreen.title, exampleNotificationTitleMobile: e.fullscreen.title, exampleNotificationMessageDesktop: e.fullscreen.message, exampleNotificationMessageMobile: e.fullscreen.message, exampleNotificationCaption: e.fullscreen.caption, acceptButton: e.fullscreen.acceptButton, cancelButton: e.fullscreen.cancelButton } : e : null } static getPromptOptionsQueryString() { const e = ee.getFullscreenPermissionMessageOptions(OneSignal.config.userConfig.promptOptions); let t = ""; if (e) { const i = ee.getPromptOptionsPostHash(); for (const s of Object.keys(i)) { const o = i[s]; t += "&" + s + "=" + o } } return t } static getPromptOptionsPostHash() { const e = ee.getFullscreenPermissionMessageOptions(OneSignal.config.userConfig.promptOptions), t = {}; if (e) { const i = { exampleNotificationTitleDesktop: "exampleNotificationTitle", exampleNotificationMessageDesktop: "exampleNotificationMessage", exampleNotificationTitleMobile: "exampleNotificationTitle", exampleNotificationMessageMobile: "exampleNotificationMessage" }; for (const o of Object.keys(i)) { const r = i[o]; e[o] && (e[r] = e[o]) } const s = ["autoAcceptTitle", "siteName", "autoAcceptTitle", "subscribeText", "showGraphic", "actionMessage", "exampleNotificationTitle", "exampleNotificationMessage", "exampleNotificationCaption", "acceptButton", "cancelButton", "timeout"]; for (let o = 0; o < s.length; o++) { const r = s[o], c = e[r], g = encodeURIComponent(c); (c || c === !1 || c === "") && (t[r] = g) } } return t } static getAppId() { return OneSignal.config?.appId || "" } static async getDeviceId() { return (await OneSignal.database.getSubscription()).deviceId || void 0 } static async getCurrentPushToken() { if (v.useSafariLegacyPush()) return window.safari?.pushNotification?.permission(OneSignal.config.safariWebId).deviceToken?.toLowerCase() || void 0; const e = await OneSignal.context.serviceWorkerManager.getRegistration(); return e ? (await e.pushManager.getSubscription())?.endpoint : void 0 } } var K = (n => (n.Native = "native", n.Push = "push", n.Category = "category", n.Sms = "sms", n.Email = "email", n.SmsAndEmail = "smsAndEmail", n))(K || {}); class be { static isCategorySlidedownConfigured(e) { if (!e) return !1; const t = be.getFirstSlidedownPromptOptionsWithType(e, K.Category); return t ? !!t.categories && t.categories.length > 0 : !1 } static isCategorySlidedownConfiguredVersion1(e) { return (e?.categories?.tags?.length || 0) > 0 } static getFirstSlidedownPromptOptionsWithType(e, t) { return e ? e.filter(i => i.type === t)[0] : void 0 } static isSlidedownAutoPromptConfigured(e) { if (!e) return !1; for (let t = 0; t < e.length; t++)if (e[t].autoPrompt) return !0; return !1 } static isSlidedownPushDependent(e) { return e === K.Push || e === K.Category } } class _ { static onNotificationPermissionChange() { _.checkAndTriggerSubscriptionChanged() } static async onInternalSubscriptionSet(e) { A.put("subscription.optedOut", e) } static async checkAndTriggerSubscriptionChanged() { j.logMethodCall("checkAndTriggerSubscriptionChanged"); const e = OneSignal.context, t = await OneSignal.context.subscriptionManager.isPushNotificationsEnabled(), i = await OneSignal.context.subscriptionManager.isOptedIn(), s = await l.getAppState(), { lastKnownPushEnabled: o, lastKnownPushId: r, lastKnownPushToken: c, lastKnownOptedIn: g } = s, u = await ee.getCurrentPushToken(), m = (await OneSignal.coreDirector.getPushSubscriptionModel())?.id; if (!(o === null || t !== o || u !== c || m !== r)) return; await e.subscriptionManager.updateNotificationTypes(), s.lastKnownPushEnabled = t, s.lastKnownPushToken = u, s.lastKnownPushId = m, s.lastKnownOptedIn = i, await l.setAppState(s); const T = { previous: { id: r, token: c, optedIn: g ?? !0 }, current: { id: m, token: u, optedIn: i } }; d.info("Push Subscription state changed: ", T), _.triggerSubscriptionChanged(T) } static async _onSubscriptionChanged(e) { _.onSubscriptionChanged_showWelcomeNotification(e?.current?.optedIn, e?.current?.id), _.onSubscriptionChanged_sendCategorySlidedownTags(e?.current?.optedIn), _.onSubscriptionChanged_evaluateNotifyButtonDisplayPredicate(), _.onSubscriptionChanged_updateCustomLink() } static async onSubscriptionChanged_sendCategorySlidedownTags(e) { if (e !== !0) return; const t = OneSignal.context.appConfig.userConfig.promptOptions?.slidedown?.prompts; be.isCategorySlidedownConfigured(t) && await OneSignal.context.tagManager.sendTags() } static async onSubscriptionChanged_showWelcomeNotification(e, t) { if (OneSignal.__doNotShowWelcomeNotification) { d.debug("Not showing welcome notification because user has previously subscribed."); return } const i = OneSignal.config?.userConfig.welcomeNotification; if (i !== void 0 && i.disable === !0 || e !== !0 || !t) return; let o = i !== void 0 && i.title !== void 0 && i.title !== null ? i.title : "", r = i !== void 0 && i.message !== void 0 && i.message !== null && i.message.length > 0 ? i.message : "Thanks for subscribing!"; const c = new URL(location.href).origin + "?_osp=do_not_open", g = i && i.url && i.url.length > 0 ? i.url : c; o = At.decodeHtmlEntities(o), r = At.decodeHtmlEntities(r), d.debug("Sending welcome notification."), ee.showLocalNotification(o, r, g, void 0, { __isOneSignalWelcomeNotification: !0 }, void 0), H.trigger(OneSignal.EVENTS.WELCOME_NOTIFICATION_SENT, { title: o, message: r, url: g }) } static async onSubscriptionChanged_evaluateNotifyButtonDisplayPredicate() { if (!OneSignal.config.userConfig.notifyButton) return; const e = OneSignal.config.userConfig.notifyButton.displayPredicate; e && typeof e == "function" && OneSignal.notifyButton && (await e() !== !1 ? (d.debug("Showing notify button because display predicate returned true."), OneSignal.notifyButton.launcher.show()) : (d.debug("Hiding notify button because display predicate returned false."), OneSignal.notifyButton.launcher.hide())) } static async onSubscriptionChanged_updateCustomLink() { OneSignal.config.userConfig.promptOptions && new wi(OneSignal.config.userConfig.promptOptions.customlink).initialize() } static triggerSubscriptionChanged(e) { H.trigger(OneSignal.EVENTS.SUBSCRIPTION_CHANGED, e) } static triggerUserChanged(e) { H.trigger(OneSignal.EVENTS.SUBSCRIPTION_CHANGED, e, We.emitter) } static triggerNotificationClick(e) { const t = { notification: e.notification, result: e.result }; return H.trigger(OneSignal.EVENTS.NOTIFICATION_CLICKED, t) } static async fireStoredNotificationClicks() { await ke(); const e = OneSignal.config.pageUrl || OneSignal.config.userConfig.pageUrl || document.URL; async function t(o) { const r = await l.getAppState(); r.pendingNotificationClickEvents[o.result.url] = null, await l.setAppState(r); const c = o.timestamp; c && (Date.now() - c) / 1e3 / 60 > 5 || _.triggerNotificationClick(o) } const i = await l.getAppState(); if (await l.get("Options", "notificationClickHandlerMatch") === "origin") { for (const o of Object.keys(i.pendingNotificationClickEvents)) if (new URL(o).origin === location.origin) { const r = i.pendingNotificationClickEvents[o]; await t(r) } } else { let o = i.pendingNotificationClickEvents[e]; if (o) await t(o); else if (!o && e.endsWith("/")) { const r = e.substring(0, e.length - 1); o = i.pendingNotificationClickEvents[r], o && await t(o) } } } static async checkAndTriggerUserChanged() { j.logMethodCall("checkAndTriggerUserChanged"); const e = await l.getUserState(), { previousOneSignalId: t, previousExternalId: i } = e, s = await OneSignal.coreDirector.getIdentityModel(), o = s?.onesignalId, r = s?.externalId; if (!(o !== t || r !== i)) return; e.previousOneSignalId = o, e.previousExternalId = r, await l.setUserState(e); const g = { current: { onesignalId: o, externalId: r } }; d.info("User state changed: ", g), _.triggerUserChanged(g) } } class h { static debug(...e) { self.shouldLog && console.debug(...e) } static trace(...e) { self.shouldLog && console.trace(...e) } static info(...e) { self.shouldLog && console.info(...e) } static warn(...e) { self.shouldLog && console.warn(...e) } static error(...e) { self.shouldLog && console.error(...e) } } function Ve(n, e) { const t = e * 1e3; let i, s = () => { }; return { promise: new Promise((r, c) => { let g = !1; i = self.setTimeout(async () => { g = !0; try { await n(), r() } catch (u) { h.error("Failed to execute callback", u), c() } }, t), s = () => { h.debug("Cancel called"), self.clearTimeout(i), g || r() } }), cancel: s } } class Be { constructor(e, t) { this.label = e, this.id = t } static ONESIGNAL_ID = "onesignal_id"; static EXTERNAL_ID = "external_id" } var at = (n => (n[n.MissingAppId = 0] = "MissingAppId", n[n.RetryLimitReached = 1] = "RetryLimitReached", n))(at || {}); class Fe extends U { reason; constructor(e) { let t; switch (e) { case 0: t = "The API call is missing an app ID."; break; case 1: t = "The API call has reached the retry limit."; break }super(t), Object.setPrototypeOf(this, Fe.prototype) } } function ct(n) { return new Promise(e => setTimeout(e, n)) } const Si = { 5: 1e4, 4: 2e4, 3: 3e4, 2: 3e4, 1: 3e4 }; class O { static get(e, t, i) { return O.call("GET", e, t, i) } static post(e, t, i) { return O.call("POST", e, t, i) } static put(e, t, i) { return O.call("PUT", e, t, i) } static delete(e, t, i) { return O.call("DELETE", e, t, i) } static patch(e, t, i) { return O.call("PATCH", e, t, i) } static call(e, t, i, s) { if (!this.requestHasAppId(t, i)) return Promise.reject(new Fe(at.MissingAppId)); const o = new Headers; if (o.append("Origin", k.getOrigin()), o.append("SDK-Version", `onesignal/web/${v.version()}`), o.append("Content-Type", "application/json;charset=UTF-8"), s) for (const g of Object.keys(s)) o.append(g, s[g]); const r = { method: e || "NO_METHOD_SPECIFIED", headers: o, cache: "no-cache" }; i && (r.body = JSON.stringify(i)); const c = `${k.getOneSignalApiUrl(void 0, t).toString()}/${t}`; return O.executeFetch(c, r) } static async executeFetch(e, t, i = 5) { if (i === 0) return Promise.reject(new Fe(at.RetryLimitReached)); try { const s = await fetch(e, t), { status: o, headers: r } = s, c = await s.json(), g = r?.get("Retry-After"); return { ok: s.ok, result: c, status: o, retryAfterSeconds: g ? parseInt(g) : void 0 } } catch (s) { if (s instanceof Error && s.name === "TypeError") return await ct(Si[i]), d.error(`OneSignal: Network timed out while calling ${e}. Retrying...`), O.executeFetch(e, t, i - 1); throw new U(`OneSignalApiBase: failed to execute HTTP call: ${s}`) } } static requestHasAppId(e, t) { if (e.startsWith("apps/")) { const i = e.split("/"); return st(i[1]) } if (e.startsWith("sync/")) { const i = e.split("/"); return st(i[1]) } return t && typeof t.app_id == "string" ? st(t.app_id) : !1 } } var oe = (n => (n[n.InvalidAppId = 0] = "InvalidAppId", n[n.AppNotConfiguredForWebPush = 1] = "AppNotConfiguredForWebPush", n[n.WrongSiteUrl = 2] = "WrongSiteUrl", n[n.MultipleInitialization = 3] = "MultipleInitialization", n[n.MissingSafariWebId = 4] = "MissingSafariWebId", n[n.Unknown = 5] = "Unknown", n))(oe || {}); class re extends U { reason; constructor(e, t) { let i; switch (e) { case 0: i = "OneSignal: This app ID does not match any existing app. Double check your app ID."; break; case 1: i = "OneSignal: This app ID does not have any web platforms enabled. Double check your app ID, or see step 1 on our setup guide (https://tinyurl.com/2x5jzk83)."; break; case 2: t && t.siteUrl ? i = `OneSignal: This web push config can only be used on ${new URL(t.siteUrl).origin}. Your current origin is ${location.origin}.` : i = "OneSignal: This web push config can not be used on the current site."; break; case 3: i = "OneSignal: The OneSignal web SDK can only be initialized once. Extra initializations are ignored. Please remove calls initializing the SDK more than once."; break; case 4: i = "OneSignal: Safari browser support on Mac OS X requires the Safari web platform to be enabled. Please see the Safari Support steps in our web setup guide."; break; case 5: i = "OneSignal: An unknown initialization error occurred."; break }super(i), this.reason = oe[e], Object.setPrototypeOf(this, re.prototype) } } function yi(n) { const e = "=".repeat((4 - n.length % 4) % 4), t = (n + e).replace(/-/g, "+").replace(/_/g, "/"), i = atob(t), s = new Uint8Array(i.length); for (let o = 0; o < i.length; ++o)s[o] = i.charCodeAt(o); return s } function Mt(n) { return encodeURIComponent(n).replace(/[!'()*]/g, e => `%${e.charCodeAt(0).toString(16).toUpperCase()}`) } class Ut { static async createUser(e, t) { const { appId: i, subscriptionId: s } = e, o = s ? { "OneSignal-Subscription-Id": s } : void 0; let r = {}; return o && (r = { ...r, ...o }), e.jwtHeader && (r = { ...r, ...e.jwtHeader }), t.refresh_device_metadata = !0, O.post(`apps/${i}/users`, t, r) } static async getUser(e, t) { const { appId: i } = e; return O.get(`apps/${i}/users/by/${t.label}/${t.id}`, e.jwtHeader) } static async updateUser(e, t, i) { const { appId: s, subscriptionId: o } = e; if (!j.isValidUuid(s)) throw new re(oe.InvalidAppId); const r = o ? { "OneSignal-Subscription-Id": o } : void 0; let c = {}; r && (c = { ...c, ...r }), e.jwtHeader && (c = { ...c, ...e.jwtHeader }); const g = { label: Mt(t.label), id: Mt(t.id) }; return O.patch(`apps/${s}/users/by/${g.label}/${g.id}`, i, c) } static async deleteUser(e, t) { const { appId: i } = e; return O.delete(`apps/${i}/users/by/${t.label}/${t.id}`, e.jwtHeader) } static async addAlias(e, t, i) { const { appId: s } = e; return O.patch(`apps/${s}/users/by/${t.label}/${t.id}/identity`, { identity: i }, e.jwtHeader) } static async getUserIdentity(e, t) { const { appId: i } = e; return O.get(`apps/${i}/users/by/${t.label}/${t.id}/identity`, e.jwtHeader) } static async deleteAlias(e, t, i) { const { appId: s } = e; return O.delete(`apps/${s}/users/by/${t.label}/${t.id}/identity/${i}`, e.jwtHeader) } static async createSubscription(e, t, i) { const { appId: s } = e; return O.post(`apps/${s}/users/by/${t.label}/${t.id}/subscriptions`, i, e.jwtHeader) } static async updateSubscription(e, t, i) { const { appId: s } = e; return O.patch(`apps/${s}/subscriptions/${t}`, { subscription: i }) } static async deleteSubscription(e, t) { const { appId: i } = e; return O.delete(`apps/${i}/subscriptions/${t}`) } static async getIdentityFromSubscription(e, t) { const { appId: i } = e; return O.get(`apps/${i}/subscriptions/${t}/user/identity`) } static async identifyUserForSubscription(e, t, i) { const { appId: s } = e; return O.patch(`apps/${s}/users/by/subscriptions/${t}/identity`, { identity: i }, e.jwtHeader) } static async transferSubscription(e, t, i, s) { const { appId: o } = e; return O.patch(`apps/${o}/subscriptions/${t}/owner`, { identity: { ...i }, retain_previous_owner: s }, e.jwtHeader) } } var J = (n => (n[n.Direct = 1] = "Direct", n[n.Indirect = 2] = "Indirect", n[n.Unattributed = 3] = "Unattributed", n[n.NotSupported = 4] = "NotSupported", n))(J || {}); class _e { static async sendOutcome(e) { d.info("Outcome payload:", e); try { await O.post("outcomes/measure", e) } catch (t) { d.error("sendOutcome", t) } } } class $e { static async downloadServerAppConfig(e) { return b.enforceAppId(e), (await O.get(`sync/${e}/web`, null))?.result } static getUserIdFromSubscriptionIdentifier(e, t, i) { return b.enforceAppId(e), O.post("players", { app_id: e, device_type: t, identifier: i, notification_types: F.TemporaryWebRecord }).then(s => s?.result?.id ? s.result.id : null).catch(s => (d.debug("Error getting user ID from subscription identifier:", s), null)) } static async updateUserSession(e, t, i) { const s = new Be(Be.ONESIGNAL_ID, t), o = { refresh_device_metadata: !0, deltas: { session_count: 1 } }; b.enforceAppId(e), b.enforceAlias(s); try { await Ut.updateUser({ appId: e, subscriptionId: i }, s, o) } catch (r) { d.debug("Error updating user session:", r) } } static async sendSessionDuration(e, t, i, s, o) { const r = { refresh_device_metadata: !0, deltas: { session_time: s } }, c = new Be(Be.ONESIGNAL_ID, t), g = { id: "os__session_duration", app_id: e, session_time: s, notification_ids: o.notificationIds, subscription: { id: i, type: N.getSubscriptionType() }, onesignal_id: t }; g.direct = o.type === J.Direct; try { await Ut.updateUser({ appId: e, subscriptionId: i }, c, r), g.notification_ids && g.notification_ids.length > 0 && await _e.sendOutcome(g) } catch (u) { d.debug("Error sending session duration:", u) } } } const Oi = "sendOutcome", vi = "sendUniqueOutcome"; class lt { outcomeName; config; appId; isUnique; constructor(e, t, i, s) { this.outcomeName = i, this.config = t, this.appId = e, this.isUnique = s } async getAttribution() { return await lt.getAttribution(this.config) } async beforeOutcomeSend() { const e = this.isUnique ? vi : Oi; return I(e, this.outcomeName), this.config ? this.outcomeName ? (await ke(), await OneSignal.context.subscriptionManager.isPushNotificationsEnabled() ? !0 : (d.warn("Reporting outcomes is supported only for subscribed users."), !1)) : (d.error("Outcome name is required"), !1) : (d.debug("Outcomes feature not supported by main application yet."), !1) } async getAttributedNotifsByUniqueOutcomeName() { return (await l.getAll("SentUniqueOutcome")).filter(t => t.outcomeName === this.outcomeName).reduce((t, i) => { const s = i.notificationIds || []; return [...t, ...s] }, []) } async getNotifsToAttributeWithUniqueOutcome(e) { const t = await this.getAttributedNotifsByUniqueOutcomeName(); return e.filter(i => t.indexOf(i) === -1) } shouldSendUnique(e, t) { return e.type === J.Unattributed ? !0 : t.length > 0 } async saveSentUniqueOutcome(e) { const t = this.outcomeName, i = await l.get("SentUniqueOutcome", t), s = await l.getCurrentSession(), r = [...i ? i.notificationIds : [], ...e], c = s ? s.startTimestamp : null; await l.put("SentUniqueOutcome", { outcomeName: t, notificationIds: r, sentDuringSession: c }) } async wasSentDuringSession() { const e = await l.get("SentUniqueOutcome", this.outcomeName); if (!e) return !1; const t = await l.getCurrentSession(), i = t && e.sentDuringSession === t.startTimestamp, s = !t && !!e.sentDuringSession; return i || s } async send(e) { const { type: t, notificationIds: i, weight: s } = e; switch (t) { case J.Direct: this.isUnique && await this.saveSentUniqueOutcome(i), await OneSignal.context.updateManager.sendOutcomeDirect(this.appId, i, this.outcomeName, s); return; case J.Indirect: this.isUnique && await this.saveSentUniqueOutcome(i), await OneSignal.context.updateManager.sendOutcomeInfluenced(this.appId, i, this.outcomeName, s); return; case J.Unattributed: if (this.isUnique) { if (await this.wasSentDuringSession()) { d.warn("(Unattributed) unique outcome was already sent during this session"); return } await this.saveSentUniqueOutcome([]) } await OneSignal.context.updateManager.sendOutcomeUnattributed(this.appId, this.outcomeName, s); return; default: d.warn("You are on a free plan. Please upgrade to use this functionality."); return } } static async getAttribution(e) { if (e.direct && e.direct.enabled) { const t = await l.getAllNotificationClickedForOutcomes(); if (t.length > 0) return { type: J.Direct, notificationIds: [t[0].notificationId] } } if (e.indirect && e.indirect.enabled) { const t = e.indirect.influencedTimePeriodMin * 60 * 1e3, s = new Date(new Date().getTime() - t).getTime(), o = await l.getAllNotificationReceivedForOutcomes(); if (d.debug(`	Found total of ${o.length} received notifications`), o.length > 0) { const r = e.indirect.influencedNotificationsLimit, c = b.sortArrayOfObjects(o, p => p.timestamp, !0, !1), g = c.filter(p => p.timestamp >= s).slice(0, r).map(p => p.notificationId); d.debug(`	Total of ${g.length} received notifications are within reporting window.`); const u = c.filter(p => g.indexOf(p.notificationId) === -1).map(p => p.notificationId); if (u.forEach(p => l.remove(tt, p)), d.debug(`	${u.length} received notifications will be deleted.`), g.length > 0) return { type: J.Indirect, notificationIds: g } } } return e.unattributed && e.unattributed.enabled ? { type: J.Unattributed, notificationIds: [] } : { type: J.NotSupported, notificationIds: [] } } } class L { static getServiceWorkerHref(e, t, i) { return L.appendServiceWorkerParams(e.workerPath.getFullPath(), t, i) } static appendServiceWorkerParams(e, t, i) { const s = new URL(e, j.getBaseUrl()).href, o = b.encodeHashAsUriComponent({ appId: t }), r = b.encodeHashAsUriComponent({ sdkVersion: i }); return `${s}?${o}&${r}` } static async upsertSession(e, t, i, s, o, r, c) { const g = await l.getCurrentSession(); if (!g) { const y = xt({ appId: e }), T = await l.getLastNotificationClickedForOutcomes(e); T && (y.notificationId = T.notificationId), await l.upsertSession(y), await L.sendOnSessionCallIfNotPlayerCreate(e, t, i, r, y); return } if (g.status === le.Active) { h.debug("Session already active", g); return } if (!g.lastDeactivatedTimestamp) { h.debug("Session is in invalid state", g); return } const u = new Date().getTime(); if (L.timeInSecondsBetweenTimestamps(u, g.lastDeactivatedTimestamp) <= s) { g.status = le.Active, g.lastActivatedTimestamp = u, g.lastDeactivatedTimestamp = null, await l.upsertSession(g); return } await L.finalizeSession(e, t, i, g, o, c); const m = xt({ appId: e }); await l.upsertSession(m), await L.sendOnSessionCallIfNotPlayerCreate(e, t, i, r, m) } static async deactivateSession(e, t, i, s, o, r) { const c = await l.getCurrentSession(); if (!c) { h.debug("No active session found. Cannot deactivate."); return } const g = () => L.finalizeSession(e, t, i, c, o, r); if (c.status === le.Inactive) return Ve(g, s); if (c.status !== le.Active) { h.warn(`Session in invalid state ${c.status}. Cannot deactivate.`); return } const u = new Date().getTime(), p = L.timeInSecondsBetweenTimestamps(u, c.lastActivatedTimestamp); c.lastDeactivatedTimestamp = u, c.accumulatedDuration += p, c.status = le.Inactive; const m = Ve(g, s); return await l.upsertSession(c), m } static async sendOnSessionCallIfNotPlayerCreate(e, t, i, s, o) { s !== De.UserCreate && (l.upsertSession(o), l.resetSentUniqueOutcomes(), await $e.updateUserSession(e, t, i)) } static async finalizeSession(e, t, i, s, o, r) { if (h.debug("Finalize session", `started: ${new Date(s.startTimestamp)}`, `duration: ${s.accumulatedDuration}s`), o) { h.debug(`send on_focus reporting session duration -> ${s.accumulatedDuration}s`); const c = await lt.getAttribution(r); h.debug("send on_focus with attribution", c), await $e.sendSessionDuration(e, t, i, s.accumulatedDuration, c) } await Promise.all([l.cleanupCurrentSession(), l.removeAllNotificationClickedForOutcomes()]), h.debug("Finalize session finished", `started: ${new Date(s.startTimestamp)}`) } static timeInSecondsBetweenTimestamps(e, t) { return e <= t ? 0 : Math.floor((e - t) / 1e3) } } var Y = (n => (n.OneSignalWorker = "OneSignal Worker", n.ThirdParty = "3rd Party", n.None = "None", n))(Y || {}); class de { static QUERY_STRING = "?"; path; constructor(e) { if (!e) throw new S("path", w.Empty); this.path = e.trim() } getQueryString() { const e = this.path.indexOf("?"); return e === -1 ? null : this.path.length > e ? this.path.substring(e + 1) : null } getWithoutQueryString() { return this.path.split(de.QUERY_STRING)[0] } getFileName() { return this.getWithoutQueryString().split("\\").pop()?.split("/").pop() } getFileNameWithQuery() { return this.path.split("\\").pop()?.split("/").pop() } getFullPath() { return this.path } getPathWithoutFileName() { const e = this.getWithoutQueryString(), t = e.lastIndexOf(this.getFileName()); let i = e.substring(0, t); return i = i.replace(/[\\/]$/, ""), i } } class ut {
        context; config; constructor(e, t) { this.context = e, this.config = t } async getRegistration() { return Ie.getRegistration(this.config.registrationOptions.scope) } async getOneSignalRegistration() { if (await this.getActiveState() === Y.OneSignalWorker) return this.getRegistration() } async getActiveState() { const e = await this.getRegistration(); if (!e) return Y.None; const t = ut.activeSwFileName(e); return this.swActiveStateByFileName(t) } static activeSwFileName(e) { const t = Ie.getAvailableServiceWorker(e); if (!t) return null; const i = new URL(t.scriptURL).pathname, s = new de(i).getFileName(); if (s == "akam-sw.js") { const r = new URLSearchParams(new URL(t.scriptURL).search).get("othersw"); if (r) return d.debug("Found a ServiceWorker under Akamai's akam-sw.js?othersw=", r), new de(new URL(r).pathname).getFileName() } return s } swActiveStateByFileName(e) { return e ? e == this.config.workerPath.getFileName() || e == "OneSignalSDK.sw.js" ? Y.OneSignalWorker : Y.ThirdParty : Y.None } async getWorkerVersion() { return new Promise(async e => { this.context.workerMessenger.once(P.WorkerVersion, t => { e(t) }), await this.context.workerMessenger.unicast(P.WorkerVersion) }) } async shouldInstallWorker() { if (!v.supportsServiceWorkers() || !OneSignal.config) return !1; const e = await this.getActiveState(); if (d.debug("[shouldInstallWorker] workerState", e), e === Y.None || e === Y.ThirdParty) { const i = await OneSignal.context.permissionManager.getNotificationPermission(OneSignal.config.safariWebId) === "granted"; return i && d.info("[shouldInstallWorker] Notification Permissions enabled, will install ServiceWorker"), i } return await this.haveParamsChanged() ? !0 : this.workerNeedsUpdate() } async haveParamsChanged() { const e = await this.getRegistration(); if (!e) return d.info("[changedServiceWorkerParams] workerRegistration not found at scope", this.config.registrationOptions.scope), !0; const t = new URL(e.scope).pathname, i = this.config.registrationOptions.scope; if (t != i) return d.info("[changedServiceWorkerParams] ServiceWorker scope changing", { a_old: t, b_new: i }), !0; const s = Ie.getAvailableServiceWorker(e), o = L.getServiceWorkerHref(this.config, this.context.appConfig.appId, v.version()); return s?.scriptURL ? o !== s.scriptURL ? (d.info("[changedServiceWorkerParams] ServiceWorker href changing:", { a_old: s?.scriptURL, b_new: o }), !0) : !1 : !0 } async workerNeedsUpdate() { d.info("[Service Worker Update] Checking service worker version..."); let e; try { e = await b.timeoutPromise(this.getWorkerVersion(), 2e3) } catch { return d.info("[Service Worker Update] Worker did not reply to version query; assuming older version and updating."), !0 } return e !== v.version() ? (d.info(`[Service Worker Update] Updating service worker from ${e} --> ${v.version()}.`), !0) : (d.info(`[Service Worker Update] Service worker version is current at ${e} (no update required).`), !1) } async establishServiceWorkerChannel() { d.debug("establishServiceWorkerChannel"); const e = this.context.workerMessenger; e.off(), e.on(P.NotificationWillDisplay, async i => { d.debug(location.origin, "Received notification display event from service worker."); const s = { notification: i.notification, preventDefault: function () { throw new Error("Browser does not support preventing display.") } }; await H.trigger(OneSignal.EVENTS.NOTIFICATION_WILL_DISPLAY, s) }), e.on(P.NotificationClicked, async i => { OneSignal.emitter.numberOfListeners(OneSignal.EVENTS.NOTIFICATION_CLICKED) === 0 ? (d.debug("notification.clicked event received, but no event listeners; storing event in IndexedDb for later retrieval."), i.result.url, await l.putNotificationClickedEventPendingUrlOpening(i)) : await _.triggerNotificationClick(i) }), e.on(P.NotificationDismissed, async i => { await H.trigger(OneSignal.EVENTS.NOTIFICATION_DISMISSED, i) }); const t = j.isSafari(); e.on(P.AreYouVisible, async i => { if (t) { const s = { timestamp: i.timestamp, focused: document.hasFocus() }; await e.directPostMessageToSW(P.AreYouVisibleResponse, s) } }) } async installWorker() { if (!await this.shouldInstallWorker()) return this.getOneSignalRegistration(); d.info("Installing worker..."), await this.getActiveState() === Y.ThirdParty && d.info("[Service Worker Installation] 3rd party service worker detected."); const t = L.getServiceWorkerHref(this.config, this.context.appConfig.appId, v.version()), i = `${j.getBaseUrl()}${this.config.registrationOptions.scope}`; d.info(`[Service Worker Installation] Installing service worker ${t} ${i}.`); let s; try { s = await navigator.serviceWorker.register(t, { scope: i, type: void 0 }) } catch (o) { d.error(`[Service Worker Installation] Installing service worker failed ${o}`), s = await this.fallbackToUserModelBetaWorker() } return d.debug("[Service Worker Installation] Service worker installed. Waiting for activation"), await Ie.waitUntilActive(s), d.debug("[Service Worker Installation] Service worker active"), await this.establishServiceWorkerChannel(), s } async fallbackToUserModelBetaWorker() {
            const e = "OneSignalSDK.sw.js", t = { workerPath: new de(`/${e}`), registrationOptions: this.config.registrationOptions }, i = L.getServiceWorkerHref(t, this.context.appConfig.appId, v.version()), s = `${j.getBaseUrl()}${this.config.registrationOptions.scope}`; d.info(`[Service Worker Installation] Attempting to install v16 Beta Worker ${i} ${s}.`); try {
                const o = await navigator.serviceWorker.register(i, { scope: s }), r = `
        [Service Worker Installation] Successfully installed v16 Beta Worker.
        Deprecation warning: support for the v16 beta worker name of ${e}
        will be removed May 5 2024. We have decided to keep the v15 name.
        To avoid breaking changes for your users, please host both worker files:
        OneSignalSDK.sw.js & OneSignalSDKWorker.js.
      `; return d.error(r), o
            } catch (o) { const r = await fetch(i); throw r.status === 403 || r.status === 404 ? new Me(r.status, r.statusText) : o }
        }
    } const Dt = { LOGIN_USER: "login-user", CREATE_SUBSCRIPTION: "create-subscription" }, je = { EXTERNAL_ID: "external_id", ONESIGNAL_ID: "onesignal_id" }; class Ii extends Le { get onesignalId() { return this.getProperty(je.ONESIGNAL_ID) } set onesignalId(e) { this.setProperty(je.ONESIGNAL_ID, e) } get externalId() { return this.getProperty(je.EXTERNAL_ID) } set externalId(e) { this.setProperty(je.EXTERNAL_ID, e) } } class Pi extends Le { constructor() { super() } get onesignalId() { return this.getProperty("onesignalId") } set onesignalId(e) { this.setProperty("onesignalId", e) } get ip() { return this.getProperty("ip") } set ip(e) { this.setProperty("ip", e) } get country() { return this.getProperty("country") } set country(e) { this.setProperty("country", e) } get language() { return this.getProperty("language") } set language(e) { this.setProperty("language", e) } get timezone_id() { return this.getProperty("timezone_id") } set timezone_id(e) { this.setProperty("timezone_id", e) } get tags() { return this.getProperty("tags") ?? {} } set tags(e) { this.setProperty("tags", e) } } const Rt = { CREATE: 0, ALTER: 1 }; class Lt extends Le { constructor(e, t, i) { super(), this.name = e, t && (this.appId = t), i && (this.onesignalId = i) } get name() { return this.getProperty("name") } set name(e) { this.setProperty("name", e) } get appId() { return this.getProperty("appId") } set appId(e) { this.setProperty("appId", e) } get onesignalId() { return this.getProperty("onesignalId") } set onesignalId(e) { this.setProperty("onesignalId", e) } get applyToRecordId() { return this.onesignalId } get createComparisonKey() { return "" } get groupComparisonType() { return Rt.ALTER } get canStartExecute() { return !Z.isLocalId(this.onesignalId) } translateIds(e) { e[this.onesignalId] && (this.onesignalId = e[this.onesignalId]) } toString() { return JSON.stringify(this.toJSON()) } } class ki extends Lt { constructor(e, t, i, s) { super(e, t, i), s && (this.subscriptionId = s) } get subscriptionId() { return this.getProperty("subscriptionId") } set subscriptionId(e) { this.setProperty("subscriptionId", e) } get createComparisonKey() { return `${this.appId}.User.${this.onesignalId}` } get modifyComparisonKey() { return `${this.appId}.User.${this.onesignalId}.Subscription.${this.subscriptionId}` } get canStartExecute() { return !Z.isLocalId(this.onesignalId) && !Z.isLocalId(this.subscriptionId) } get applyToRecordId() { return this.subscriptionId } translateIds(e) { super.translateIds(e), e[this.subscriptionId] && (this.subscriptionId = e[this.subscriptionId]) } } class Ni extends ki { constructor(e, t, i, s) { super(e, t, i), s && (this.sdk = N.getSdk(), this.device_model = N.getDeviceModel(), this.device_os = N.getDeviceOS(), this.enabled = s.enabled, this.notification_types = s.notification_types, this.subscriptionId = s.subscriptionId, this.token = s.token, this.type = s.type, this.web_auth = s.web_auth, this.web_p256 = s.web_p256) } get type() { return this.getProperty("type") } set type(e) { this.setProperty("type", e) } get token() { return this.getProperty("token") } set token(e) { this.setProperty("token", e) } get enabled() { return this.getProperty("enabled") } set enabled(e) { this.setProperty("enabled", e) } get notification_types() { return this.getProperty("notification_types") } set notification_types(e) { this.setProperty("notification_types", e) } get sdk() { return this.getProperty("sdk") } set sdk(e) { this.setProperty("sdk", e) } get device_model() { return this.getProperty("device_model") } set device_model(e) { this.setProperty("device_model", e) } get device_os() { return this.getProperty("device_os") } set device_os(e) { this.setProperty("device_os", e) } get web_auth() { return this.getProperty("web_auth") } set web_auth(e) { this.setProperty("web_auth", e) } get web_p256() { return this.getProperty("web_p256") } set web_p256(e) { this.setProperty("web_p256", e) } } class xi extends Ni { constructor(e) { super(Dt.CREATE_SUBSCRIPTION, e?.appId, e?.onesignalId, e) } get canStartExecute() { return !Z.isLocalId(this.onesignalId) } get applyToRecordId() { return this.onesignalId } translateIds(e) { e[this.onesignalId] && (this.onesignalId = e[this.onesignalId]) } } class Ti extends Lt { constructor(e, t, i, s) { super(Dt.LOGIN_USER, e, t), i && (this.externalId = i), s && (this.existingOnesignalId = s) } get externalId() { return this.getProperty("externalId") } set externalId(e) { this.setProperty("externalId", e) } get existingOnesignalId() { return this.getProperty("existingOnesignalId") } set existingOnesignalId(e) { this.setProperty("existingOnesignalId", e) } get createComparisonKey() { return `${this.appId}.User.${this.onesignalId}` } get modifyComparisonKey() { return "" } get groupComparisonType() { return Rt.CREATE } get canStartExecute() { return !this.existingOnesignalId || !Z.isLocalId(this.existingOnesignalId) } get applyToRecordId() { return this.existingOnesignalId ?? this.onesignalId } translateIds(e) { this.existingOnesignalId && e[this.existingOnesignalId] && (this.existingOnesignalId = e[this.existingOnesignalId]) } } class Ei { static async createUserOnServer() { if (q.createOrGetInstance().isCreatingUser) return; const t = OneSignal.coreDirector.getIdentityModel(), i = ee.getAppId(), s = await OneSignal.coreDirector.getPushSubscriptionModel(); if (!s) return d.info("No push subscription found"); s.id = s.id ?? Z.createLocalId(); const { id: o, ...r } = s.toJSON(); q.createOrGetInstance().isCreatingUser = !0, OneSignal.coreDirector.operationRepo.enqueue(new Ti(i, t.onesignalId, t.externalId)), await OneSignal.coreDirector.operationRepo.enqueueAndWait(new xi({ ...r, appId: i, onesignalId: t.onesignalId, subscriptionId: o })) } static resetUserMetaProperties() { const e = q.createOrGetInstance(); e.isCreatingUser = !1 } static resetUserModels() { const e = new Ii, t = new Pi, i = Z.createLocalId(); e.onesignalId = i, t.onesignalId = i, OneSignal.coreDirector.identityModelStore.replace(e), OneSignal.coreDirector.propertiesModelStore.replace(t) } } class xe extends U { constructor() { super("This code is not implemented yet."), Object.setPrototypeOf(this, xe.prototype) } } var me = (n => (n[n.Blocked = 0] = "Blocked", n[n.Dismissed = 1] = "Dismissed", n[n.Default = 2] = "Default", n))(me || {}); class pe extends U { reason; constructor(e) { let t; switch (e) { case 1: t = "The user dismissed the permission prompt."; break; case 0: t = "Notification permissions are blocked."; break; case 2: t = "Notification permissions have not been granted yet."; break }super(t), this.reason = e, Object.setPrototypeOf(this, pe.prototype) } } var Wt = (n => (n[n.InvalidSafariSetup = 0] = "InvalidSafariSetup", n[n.Blocked = 1] = "Blocked", n[n.Dismissed = 2] = "Dismissed", n))(Wt || {}); class dt extends U { constructor(e) { let t; switch (e) { case 0: t = "The Safari site URL, icon size, or push certificate is invalid, or Safari is in a private session."; break; case 1: t = "Notification permissions are blocked."; break; case 2: t = "The notification permission prompt was dismissed."; break }super(t), Object.setPrototypeOf(this, dt.prototype) } } var ge = (n => (n.Default = "default", n.Granted = "granted", n.Denied = "denied", n))(ge || {}); class ae { w3cEndpoint; w3cP256dh; w3cAuth; safariDeviceToken; static setFromW3cSubscription(e) { const t = new ae; if (e && (t.w3cEndpoint = new URL(e.endpoint), e.getKey)) { let i = null; try { i = e.getKey("p256dh") } catch { } let s = null; try { s = e.getKey("auth") } catch { } if (i) { const o = btoa(String.fromCharCode.apply(null, new Uint8Array(i))); t.w3cP256dh = o } if (s) { const o = btoa(String.fromCharCode.apply(null, new Uint8Array(s))); t.w3cAuth = o } } return t } setFromSafariSubscription(e) { e && (this.safariDeviceToken = e) } serialize() { return { w3cEndpoint: this.w3cEndpoint ? this.w3cEndpoint.toString() : null, w3cP256dh: this.w3cP256dh, w3cAuth: this.w3cAuth, safariDeviceToken: this.safariDeviceToken } } static deserialize(e) { const t = new ae; if (!e) return t; try { t.w3cEndpoint = new URL(e.w3cEndpoint) } catch { } return t.w3cP256dh = e.w3cP256dh, t.w3cAuth = e.w3cAuth, t.safariDeviceToken = e.safariDeviceToken, t } } var we = (n => (n[n.ResubscribeExisting = 0] = "ResubscribeExisting", n[n.SubscribeNew = 1] = "SubscribeNew", n))(we || {}), pt = (n => (n[n.DestroySubscription = 0] = "DestroySubscription", n[n.MarkUnsubscribed = 1] = "MarkUnsubscribed", n))(pt || {}); const Ci = "99999999-9999-9999-9999-999999999999"; class te { context; config; safariPermissionPromptFailed = !1; constructor(e, t) { this.context = e, this.config = t } async isPushNotificationsEnabled() { const e = await this.getSubscriptionState(); return e.subscribed && !e.optedOut } async isOptedIn() { const e = await this.getSubscriptionState(); return await OneSignal.context.permissionManager.getPermissionStatus() === "granted" && !e.optedOut } async isOptedOut(e) { I("isOptedOut", e); const { optedOut: t } = await l.getSubscription(); return di(e, t), t } async subscribe(e) { const t = k.getWindowEnv(); let i; switch (t) { case D.ServiceWorker: i = await this.subscribeFcmFromWorker(e); break; case D.Host: if (await OneSignal.context.permissionManager.getPermissionStatus() === ge.Denied) throw new pe(me.Blocked); if (v.useSafariLegacyPush()) { i = await this.subscribeSafari(), await this._updatePushSubscriptionModelWithRawSubscription(i), d.info("Installing SW on Safari"); try { await this.context.serviceWorkerManager.installWorker(), d.info("SW on Safari successfully installed") } catch { d.error("SW on Safari failed to install.") } } else i = await this.subscribeFcmFromPage(e), await this._updatePushSubscriptionModelWithRawSubscription(i); break; default: throw new ie(ce.UnsupportedEnvironment) }return i } async _updatePushSubscriptionModelWithRawSubscription(e) { const t = await OneSignal.coreDirector.getPushSubscriptionModel(); if (!t) return OneSignal.coreDirector.generatePushSubscriptionModel(e), Ei.createUserOnServer(); const i = new N(e).serialize(); t.mergeData(i) } async updateNotificationTypes() { const e = await this.getNotificationTypes(); await this.updatePushSubscriptionNotificationTypes(e) } async getNotificationTypes() { const { optedOut: e } = await l.getSubscription(); return e ? F.UserOptedOut : await OneSignal.context.permissionManager.getPermissionStatus() === "granted" ? F.Subscribed : F.NoNativePermission } async updatePushSubscriptionNotificationTypes(e) { const t = await OneSignal.coreDirector.getPushSubscriptionModel(); if (!t) { d.info("No Push Subscription yet to update notification_types."); return } t.notification_types = e, t.enabled = e === F.Subscribed } async registerSubscription(e, t) { e && (e = ae.deserialize(e)), await this.isAlreadyRegisteredWithOneSignal() ? await this.context.updateManager.sendPushDeviceRecordUpdate() : this.context.sessionManager.upsertSession(De.UserCreate); const i = await l.getSubscription(); return i.deviceId = Ci, i.optedOut = !1, e ? v.useSafariLegacyPush() ? i.subscriptionToken = e.safariDeviceToken : i.subscriptionToken = e.w3cEndpoint ? e.w3cEndpoint.toString() : null : i.subscriptionToken = null, await l.setSubscription(i), k.getWindowEnv() !== D.ServiceWorker && H.trigger(OneSignal.EVENTS.REGISTERED), typeof OneSignal < "u" && (OneSignal._sessionInitAlreadyRunning = !1), i } static async requestPresubscribeNotificationPermission() { return await te.requestNotificationPermission() } async unsubscribe(e) { if (e === pt.DestroySubscription) throw new xe; if (e === pt.MarkUnsubscribed) if (k.getWindowEnv() === D.ServiceWorker) await l.put("Options", { key: "optedOut", value: !0 }); else throw new xe; else throw new xe } static async requestNotificationPermission() { return await window.Notification.requestPermission() } async isAlreadyRegisteredWithOneSignal() { const { deviceId: e } = await l.getSubscription(); return !!e } async subscribeSafariPromptPermission() { const e = t => new Promise(i => { window.safari?.pushNotification?.requestPermission(t, this.config.safariWebId, { app_id: this.config.appId }, s => { s && s.deviceToken ? i(s.deviceToken.toLowerCase()) : i(null) }) }); return this.safariPermissionPromptFailed ? e(`${k.getOneSignalApiUrl().toString()}/safari`) : e(`${k.getOneSignalApiUrl().toString()}/safari/apps/${this.config.appId}`) } async subscribeSafari() { const e = new ae; if (!this.config.safariWebId) throw new re(oe.MissingSafariWebId); const { deviceToken: t } = window.safari?.pushNotification?.permission(this.config.safariWebId) || {}; if (t) return e.setFromSafariSubscription(t.toLowerCase()), e; H.trigger(OneSignal.EVENTS.PERMISSION_PROMPT_DISPLAYED); const i = await this.subscribeSafariPromptPermission(); if (ne.triggerNotificationPermissionChanged(), i) e.setFromSafariSubscription(i); else throw this.safariPermissionPromptFailed = !0, new dt(Wt.InvalidSafariSetup); return e } async subscribeFcmFromPage(e) { if (k.getWindowEnv() === D.Host && Notification.permission === ge.Default) { await H.trigger(OneSignal.EVENTS.PERMISSION_PROMPT_DISPLAYED); const i = await te.requestPresubscribeNotificationPermission(), s = i === ge.Default; switch (await ne.triggerNotificationPermissionChanged(s), i) { case ge.Default: throw d.debug("Exiting subscription and not registering worker because the permission was dismissed."), OneSignal._sessionInitAlreadyRunning = !1, new pe(me.Dismissed); case ge.Denied: throw d.debug("Exiting subscription and not registering worker because the permission was blocked."), OneSignal._sessionInitAlreadyRunning = !1, new pe(me.Blocked) } } let t; try { t = await this.context.serviceWorkerManager.installWorker() } catch (i) { throw i instanceof Me && (i.status === 403 ? await this.context.subscriptionManager.registerFailedSubscription(F.ServiceWorkerStatus403, this.context) : i.status === 404 && await this.context.subscriptionManager.registerFailedSubscription(F.ServiceWorkerStatus404, this.context)), i } if (!t) throw new Error("OneSignal service worker not found!"); return d.debug("[Subscription Manager] Service worker is ready to continue subscribing."), await this.subscribeWithVapidKey(t.pushManager, e) } async subscribeFcmFromWorker(e) { const t = self.registration; if (!t.active && R().name !== "firefox") throw new ie(ce.ServiceWorkerNotActivated); const i = await t.pushManager.permissionState({ userVisibleOnly: !0 }); if (i === "denied") throw new pe(me.Blocked); if (i === "prompt") throw new pe(me.Default); return await this.subscribeWithVapidKey(t.pushManager, e) } getVapidKeyForBrowser() { let e; if (R().name === "firefox" ? e = this.config.onesignalVapidPublicKey : e = this.config.vapidPublicKey, e) return yi(e).buffer } async subscribeWithVapidKey(e, t) { const i = await e.getSubscription(); switch (t) { case we.ResubscribeExisting: if (!i) break; i.options ? d.debug("[Subscription Manager] An existing push subscription exists and it's options is not null.") : (d.debug("[Subscription Manager] An existing push subscription exists and options is null. Unsubscribing from push first now."), await te.doPushUnsubscribe(i)); break; case we.SubscribeNew: i && await te.doPushUnsubscribe(i); break }const [s, o] = await te.doPushSubscribe(e, this.getVapidKeyForBrowser()); return await te.updateSubscriptionTime(o, s.expirationTime), ae.setFromW3cSubscription(s) } static async updateSubscriptionTime(e, t) { const i = await l.getSubscription(); e && (i.createdAt = new Date().getTime()), i.expirationTime = t, await l.setSubscription(i) } static async doPushUnsubscribe(e) { d.debug("[Subscription Manager] Unsubscribing existing push subscription."); const t = await e.unsubscribe(); return d.debug(`[Subscription Manager] Unsubscribing existing push subscription result: ${t}`), t } static async doPushSubscribe(e, t) { if (!t) throw new Error("Missing required 'applicationServerKey' to subscribe for push notifications!"); const i = { userVisibleOnly: !0, applicationServerKey: t }; d.debug("[Subscription Manager] Subscribing to web push with these options:", i); try { const s = await e.getSubscription(); return [await e.subscribe(i), !s] } catch (s) { if (s instanceof ie) { d.warn("[Subscription Manager] Couldn't re-subscribe due to applicationServerKey changing, unsubscribe and attempting to subscribe with new key.", s); const o = await e.getSubscription(); return o && await te.doPushUnsubscribe(o), [await e.subscribe(i), !0] } else throw s } } async isSubscriptionExpiring() { if (await this.context.serviceWorkerManager.getActiveState() !== Y.OneSignalWorker) return !1; const t = await this.context.serviceWorkerManager.getOneSignalRegistration(); if (!t || !t.pushManager) return !1; const i = await t.pushManager.getSubscription(); if (!i || !i.expirationTime) return !1; let { createdAt: s } = await l.getSubscription(); s || (s = new Date().getTime() + 31536e6); const o = s + (i.expirationTime - s) / 2; return !!i.expirationTime && (new Date().getTime() >= i.expirationTime || new Date().getTime() >= o) } async getSubscriptionState() { switch (k.getWindowEnv()) { case D.ServiceWorker: { const t = await self.registration.pushManager.getSubscription(), { optedOut: i } = await l.getSubscription(); return { subscribed: !!t, optedOut: !!i } } default: return this.getSubscriptionStateFromBrowserContext() } } async getSubscriptionStateFromBrowserContext() { const { optedOut: e, subscriptionToken: t } = await l.getSubscription(), i = await OneSignal.coreDirector.getPushSubscriptionModel(), s = Pe(i); if (v.useSafariLegacyPush()) { const g = window.safari?.pushNotification?.permission(this.config.safariWebId); return { subscribed: !!(s && t && g?.permission === "granted" && g?.deviceToken), optedOut: !!e } } const o = await this.context.serviceWorkerManager.getOneSignalRegistration(), r = await this.context.permissionManager.getNotificationPermission(this.context.appConfig.safariWebId); return o ? { subscribed: !!(s && t && r === ge.Granted), optedOut: !!e } : { subscribed: !1, optedOut: !!e } } async registerFailedSubscription(e, t) { t.pageViewManager.isFirstPageView() && (t.subscriptionManager.registerSubscription(new ae, e), t.pageViewManager.incrementPageViewCount()) } } class Vt { static getServiceWorkerManager(e) { const t = e.appConfig, i = { workerPath: new de("OneSignalSDKWorker.js"), registrationOptions: { scope: "/" } }; return t.userConfig && (t.userConfig.path && (i.workerPath = new de(`${t.userConfig.path}${t.userConfig.serviceWorkerPath}`)), t.userConfig.serviceWorkerParam && (i.registrationOptions = t.userConfig.serviceWorkerParam)), new ut(e, i) } static getSubscriptionManager(e) { const t = e.appConfig, i = { safariWebId: t.safariWebId, appId: t.appId, vapidPublicKey: t.vapidPublicKey, onesignalVapidPublicKey: t.onesignalVapidPublicKey }; return new te(e, i) } } class Ai { context; onSessionSent; constructor(e) { this.context = e, this.onSessionSent = e.pageViewManager.getPageViewCount() > 1 } async sendPushDeviceRecordUpdate() { if (!q.singletonInstance?.onesignalId) { d.debug("Not sending the update because user is not registered with OneSignal (no onesignal_id)"); return } this.onSessionSent || await this.sendOnSessionUpdate() } async sendOnSessionUpdate() { if (this.onSessionSent || !this.context.pageViewManager.isFirstPageView()) return; if (!await this.context.subscriptionManager.isAlreadyRegisteredWithOneSignal()) { d.debug("Not sending the on session because user is not registered with OneSignal (no device id)"); return } if (!((await OneSignal.coreDirector.getPushSubscriptionModel())?.notification_types !== F.Subscribed && OneSignal.config?.enableOnSession !== !0)) try { this.context.sessionManager.upsertSession(De.UserNewSession), this.onSessionSent = !0 } catch (i) { i instanceof Error && d.error(`Failed to update user session. Error "${i.message}" ${i.stack}`) } } async sendOutcomeDirect(e, t, i, s) { I("sendOutcomeDirect"); const o = await OneSignal.coreDirector.getPushSubscriptionModel(); if (o && Pe(o)) { const r = { id: i, app_id: e, notification_ids: t, direct: !0, subscription: { id: o.id, type: N.getSubscriptionType() } }; s !== void 0 && (r.weight = s), await _e.sendOutcome(r); return } d.warn("Send outcome aborted because pushSubscriptionModel is not available.") } async sendOutcomeInfluenced(e, t, i, s) { I("sendOutcomeInfluenced"); const o = await OneSignal.coreDirector.getPushSubscriptionModel(); if (o && Pe(o)) { const r = { id: i, app_id: e, notification_ids: t, direct: !1, subscription: { id: o.id, type: N.getSubscriptionType() } }; s !== void 0 && (r.weight = s), await _e.sendOutcome(r); return } d.warn("Send outcome aborted because pushSubscriptionModel is not available.") } async sendOutcomeUnattributed(e, t, i) { I("sendOutcomeUnattributed"); const s = await OneSignal.coreDirector.getPushSubscriptionModel(); if (s && Pe(s)) { const o = { id: t, app_id: e, subscription: { id: s.id, type: N.getSubscriptionType() } }; i !== void 0 && (o.weight = i), await _e.sendOutcome(o); return } d.warn("Send outcome aborted because pushSubscriptionModel is not available.") } } class Mi { async upsertSession(e) { } async setupSessionEventListeners() { } } class gt { appConfig; subscriptionManager; serviceWorkerManager; pageViewManager; sessionManager; permissionManager; workerMessenger; updateManager; constructor(e) { this.appConfig = e, this.subscriptionManager = Vt.getSubscriptionManager(this), this.serviceWorkerManager = Vt.getServiceWorkerManager(this), this.pageViewManager = new Ae, this.sessionManager = new Mi, this.permissionManager = new Ke, this.workerMessenger = new wt(this), this.updateManager = new Ai(this) } } const ft = { reportingThreshold: 30, enableOnSessionForUnsubcribed: !1, enableOnFocus: !0 }, z = { pageViews: 1, timeDelay: 0 }, X = { actionMessage: "We'd like to show you notifications for the latest news and updates.", acceptButton: "Allow", cancelButton: "Cancel", categoryDefaults: { updateMessage: "Update your push notification subscription preferences.", positiveUpdateButton: "Save Preferences", negativeUpdateButton: "Cancel" }, confirmMessage: "Thank You!" }, Ui = { type: K.Push, text: { actionMessage: X.actionMessage, acceptButton: X.acceptButton, cancelButton: X.cancelButton }, autoPrompt: !1, delay: z }; var He = (n => (n.TypicalSite = "typical", n.WordPress = "wordpress", n.Shopify = "shopify", n.Blogger = "blogger", n.Magento = "magento", n.Drupal = "drupal", n.SquareSpace = "squarespace", n.Joomla = "joomla", n.Weebly = "weebly", n.Wix = "wix", n.Custom = "custom", n))(He || {}); class Te { static convertTagsApiToBooleans(e) { const t = {}; return Object.keys(e).forEach(i => { t[i] = e[i] === "1" }), t } static convertTagsBooleansToApi(e) { const t = {}; return Object.keys(e).forEach(i => { t[i] = e[i] === !0 ? "1" : "0" }), t } static getObjectDifference(e, t) { const i = {}; return Object.keys(e).forEach(s => { t[s] !== e[s] && (i[s] = e[s]) }), i } static markAllTagsAsSpecified(e, t) { e.forEach(i => { i.checked = t }) } static isTagObjectEmpty(e) { return Object.keys(e).length === 0 } static getCheckedTagCategories(e, t) { if (!t) return e; if (Te.isTagObjectEmpty(t)) { const o = nt(e); return Te.markAllTagsAsSpecified(o, !0), o } return nt(e).map(o => { const r = t[o.tag]; return o.checked = Te.getCheckedStatusForTagValue(r), o }) } static getCheckedStatusForTagValue(e) { return e === void 0 ? !0 : e } static limitCategoriesToMaxCount(e, t) { let i = nt(e); return i = e.slice(0, t), i } } class Se { static upgradeConfigToVersionTwo(e) { Se.isPromptOptionsVersion0(e.promptOptions) && (e.promptOptions = Se.convertConfigToVersionOne(e.promptOptions)), Se.isSlidedownConfigVersion1(e.promptOptions?.slidedown) && e.promptOptions?.slidedown && (e.promptOptions.slidedown = Se.convertConfigToVersionTwo(e.promptOptions?.slidedown)) } static convertConfigToVersionOne(e) { e.slidedown || (e.slidedown = {}); const { acceptButtonText: t, cancelButtonText: i, actionMessage: s } = e.slidedown, o = e.acceptButtonText || e.acceptButton, r = e.cancelButtonText || e.cancelButton; return e.slidedown.acceptButtonText = t || o, e.slidedown.cancelButtonText = i || r, e.slidedown.actionMessage = s || e.actionMessage, e } static convertConfigToVersionTwo(e) { const t = be.isCategorySlidedownConfiguredVersion1(e) ? K.Category : K.Push; let i, s; return t === K.Category && (i = e.categories?.positiveUpdateButton, s = e.categories?.negativeUpdateButton), { prompts: [...e.prompts || [], { type: t, autoPrompt: e.autoPrompt, text: { actionMessage: e.actionMessage, acceptButton: e.acceptButton || e.acceptButtonText, cancelButton: e.cancelButton || e.cancelButtonText, positiveUpdateButton: i, negativeUpdateButton: s, updateMessage: e?.categories?.updateMessage }, delay: { pageViews: e.pageViews, timeDelay: e.timeDelay }, categories: e?.categories?.tags }] } } static isPromptOptionsVersion0(e) { if (e) { const t = ["acceptButtonText", "cancelButtonText", "actionMessage"]; for (let i = 0; i < t.length; i++)if (e.hasOwnProperty(t[i])) return !0 } return !1 } static isSlidedownConfigVersion1(e) { if (e) { const t = ["enabled", "autoPrompt", "pageViews", "timeDelay", "acceptButton", "acceptButtonText", "cancelButton", "cancelButtonText", "actionMessage", "customizeTextEnabled", "categories"]; for (let i = 0; i < t.length; i++)if (e.hasOwnProperty(t[i])) return !0 } return !1 } } const Di = 10; class Ri { static async getAppConfig(e, t) { try { if (!e || !e.appId || !j.isValidUuid(e.appId)) throw new re(oe.InvalidAppId); const i = await t(e.appId); Se.upgradeConfigToVersionTwo(e); const s = this.getMergedConfig(e, i); return this.checkUnsupportedSubdomain(s), this.checkRestrictedOrigin(s), s } catch (i) { if (i) { if (i.code === 1) throw new re(oe.InvalidAppId); if (i.code === 2) throw new re(oe.AppNotConfiguredForWebPush) } throw i } } static checkUnsupportedSubdomain(e) { const t = !self.isSecureContext; if (e.hasUnsupportedSubdomain || t) throw t ? new Error("OneSignalSDK: HTTP sites are no longer supported starting with version 16 (User Model), your public site must start with https://. Please visit the OneSignal dashboard's Settings > Web Configuration to find this option.") : new Error(`OneSignalSDK: The "My site is not fully HTTPS" option is no longer supported starting with version 16 (User Model) of the OneSignal SDK. Please visit the OneSignal dashboard's Settings > Web Configuration to find this option.`) } static checkRestrictedOrigin(e) { if (e.restrictedOriginEnabled && k.getWindowEnv() === D.Host && !this.doesCurrentOriginMatchConfigOrigin(e.origin)) throw new re(oe.WrongSiteUrl, { siteUrl: e.origin }) } static doesCurrentOriginMatchConfigOrigin(e) { try { return location.origin === new URL(e).origin } catch { return !1 } } static getIntegrationCapabilities(e) { switch (e) { case He.Custom: case He.WordPress: return { configuration: 1 }; default: return { configuration: 0 } } } static getMergedConfig(e, t) { const i = this.getConfigIntegrationKind(t), s = this.hasUnsupportedSubdomainForConfigIntegrationKind(i, e, t), o = this.getUserConfigForConfigIntegrationKind(i, e, t); return { appId: t.app_id, hasUnsupportedSubdomain: s, siteName: t.config.siteInfo.name, origin: t.config.origin, restrictedOriginEnabled: t.features.restrict_origin && t.features.restrict_origin.enable, safariWebId: t.config.safari_web_id, vapidPublicKey: t.config.vapid_public_key, onesignalVapidPublicKey: t.config.onesignal_vapid_public_key, userConfig: o, enableOnSession: b.valueOrDefault(t.features.enable_on_session, ft.enableOnSessionForUnsubcribed), sessionThreshold: b.valueOrDefault(t.features.session_threshold, ft.reportingThreshold), enableSessionDuration: b.valueOrDefault(t.features.web_on_focus_enabled, ft.enableOnFocus) } } static getConfigIntegrationKind(e) { return e.config.integration ? e.config.integration.kind : He.Custom } static getCustomLinkConfig(e) { const t = { enabled: !1, style: "button", size: "medium", unsubscribeEnabled: !1, text: { explanation: "", subscribe: "", unsubscribe: "" }, color: { button: "", text: "" } }; if (!e || !e.config || !e.config.staticPrompts || !e.config.staticPrompts.customlink || !e.config.staticPrompts.customlink.enabled) return t; const i = e.config.staticPrompts.customlink; return { enabled: i.enabled, style: i.style, size: i.size, unsubscribeEnabled: i.unsubscribeEnabled, text: i.text ? { subscribe: i.text.subscribe, unsubscribe: i.text.unsubscribe, explanation: i.text.explanation } : t.text, color: i.color ? { button: i.color.button, text: i.color.text } : t.color } } static injectDefaultsIntoPromptOptions(e, t, i) { let s = { enabled: !1 }; e && e.customlink && (s = e.customlink); const o = t.customlink, r = { ...e, customlink: { enabled: b.getValueOrDefault(s.enabled, o.enabled), style: b.getValueOrDefault(s.style, o.style), size: b.getValueOrDefault(s.size, o.size), unsubscribeEnabled: b.getValueOrDefault(s.unsubscribeEnabled, o.unsubscribeEnabled), text: { subscribe: b.getValueOrDefault(s.text ? s.text.subscribe : void 0, o.text.subscribe), unsubscribe: b.getValueOrDefault(s.text ? s.text.unsubscribe : void 0, o.text.unsubscribe), explanation: b.getValueOrDefault(s.text ? s.text.explanation : void 0, o.text.explanation) }, color: { button: b.getValueOrDefault(s.color ? s.color.button : void 0, o.color.button), text: b.getValueOrDefault(s.color ? s.color.text : void 0, o.color.text) } } }; return r.slidedown ? r.slidedown.prompts = r.slidedown?.prompts?.map(c => { if (c.type = b.getValueOrDefault(c.type, K.Push), c.type === K.Category && (c.text = { ...c.text, positiveUpdateButton: b.getValueOrDefault(c.text?.positiveUpdateButton, X.categoryDefaults.positiveUpdateButton), negativeUpdateButton: b.getValueOrDefault(c.text?.negativeUpdateButton, X.categoryDefaults.negativeUpdateButton), updateMessage: b.getValueOrDefault(c.text?.updateMessage, X.categoryDefaults.updateMessage) }), c.text = { ...c.text, actionMessage: b.getValueOrDefault(c.text?.actionMessage, X.actionMessage), acceptButton: b.getValueOrDefault(c.text?.acceptButton, X.acceptButton), cancelButton: b.getValueOrDefault(c.text?.cancelButton, X.cancelButton), confirmMessage: b.getValueOrDefault(c.text?.confirmMessage, X.confirmMessage) }, c.autoPrompt = b.getValueOrDefault(c.autoPrompt, !0), c.delay = { pageViews: b.getValueOrDefault(c.delay?.pageViews, z.pageViews), timeDelay: b.getValueOrDefault(c.delay?.timeDelay, z.timeDelay) }, c.categories) { const { categories: g } = c; c.categories = Te.limitCategoriesToMaxCount(g, Di) } return c }) : (r.slidedown = { prompts: [] }, r.slidedown.prompts = [Ui]), r.native ? (r.native.enabled = !!r.native.enabled, r.native.autoPrompt = r.native.hasOwnProperty("autoPrompt") ? !!r.native.enabled && !!r.native.autoPrompt : !!r.native.enabled, r.native.pageViews = b.getValueOrDefault(r.native.pageViews, z.pageViews), r.native.timeDelay = b.getValueOrDefault(r.native.timeDelay, z.timeDelay)) : r.native = { enabled: !1, autoPrompt: !1, pageViews: z.pageViews, timeDelay: z.timeDelay }, i.autoRegister === !0 && (r.native.enabled = !0, r.native.autoPrompt = !0), r.autoPrompt = r.native.autoPrompt || be.isSlidedownAutoPromptConfigured(r.slidedown.prompts), r } static getPromptOptionsForDashboardConfiguration(e) { const t = e.config.staticPrompts, i = t.native ? { enabled: t.native.enabled, autoPrompt: t.native.enabled && t.native.autoPrompt !== !1, pageViews: b.getValueOrDefault(t.native.pageViews, z.pageViews), timeDelay: b.getValueOrDefault(t.native.timeDelay, z.timeDelay) } : { enabled: !1, autoPrompt: !1, pageViews: z.pageViews, timeDelay: z.timeDelay }, { prompts: s } = t.slidedown; return { autoPrompt: i.autoPrompt || be.isSlidedownAutoPromptConfigured(s), native: i, slidedown: { prompts: s }, fullscreen: { enabled: t.fullscreen.enabled, actionMessage: t.fullscreen.actionMessage, acceptButton: t.fullscreen.acceptButton, cancelButton: t.fullscreen.cancelButton, title: t.fullscreen.title, message: t.fullscreen.message, caption: t.fullscreen.caption, autoAcceptTitle: t.fullscreen.autoAcceptTitle }, customlink: this.getCustomLinkConfig(e) } } static getServiceWorkerValues(e, t) { const i = e.serviceWorkerOverrideForTypical, s = i ? b.getValueOrDefault(e.path, t.config.serviceWorker.path) : t.config.serviceWorker.path, o = i ? b.getValueOrDefault(e.serviceWorkerParam, { scope: t.config.serviceWorker.registrationScope }) : { scope: t.config.serviceWorker.registrationScope }, r = i ? b.getValueOrDefault(e.serviceWorkerPath, t.config.serviceWorker.workerName) : t.config.serviceWorker.workerName; return { path: s, serviceWorkerParam: o, serviceWorkerPath: r } } static getUserConfigForConfigIntegrationKind(e, t, i) { switch (this.getIntegrationCapabilities(e).configuration) { case 0: { const { path: o, serviceWorkerPath: r, serviceWorkerParam: c } = this.getServiceWorkerValues(t, i); return { appId: i.app_id, autoRegister: !1, autoResubscribe: i.config.autoResubscribe, path: o, serviceWorkerPath: r, serviceWorkerParam: c, subdomainName: i.config.siteInfo.proxyOrigin, promptOptions: this.getPromptOptionsForDashboardConfiguration(i), welcomeNotification: { disable: !i.config.welcomeNotification.enable, title: i.config.welcomeNotification.title, message: i.config.welcomeNotification.message, url: i.config.welcomeNotification.url }, notifyButton: { enable: i.config.staticPrompts.bell.enabled, displayPredicate: i.config.staticPrompts.bell.hideWhenSubscribed ? () => !OneSignal.User.PushSubscription.optedIn : null, size: i.config.staticPrompts.bell.size, position: i.config.staticPrompts.bell.location, showCredit: !1, offset: { bottom: `${i.config.staticPrompts.bell.offset.bottom}px`, left: `${i.config.staticPrompts.bell.offset.left}px`, right: `${i.config.staticPrompts.bell.offset.right}px` }, colors: { "circle.background": i.config.staticPrompts.bell.color.main, "circle.foreground": i.config.staticPrompts.bell.color.accent, "badge.background": "black", "badge.foreground": "white", "badge.bordercolor": "black", "pulse.color": i.config.staticPrompts.bell.color.accent, "dialog.button.background.hovering": i.config.staticPrompts.bell.color.main, "dialog.button.background.active": i.config.staticPrompts.bell.color.main, "dialog.button.background": i.config.staticPrompts.bell.color.main, "dialog.button.foreground": "white" }, text: { "tip.state.unsubscribed": i.config.staticPrompts.bell.tooltip.unsubscribed, "tip.state.subscribed": i.config.staticPrompts.bell.tooltip.subscribed, "tip.state.blocked": i.config.staticPrompts.bell.tooltip.blocked, "message.prenotify": i.config.staticPrompts.bell.tooltip.unsubscribed, "message.action.subscribing": i.config.staticPrompts.bell.message.subscribing, "message.action.subscribed": i.config.staticPrompts.bell.message.subscribing, "message.action.resubscribed": i.config.staticPrompts.bell.message.subscribing, "message.action.unsubscribed": i.config.staticPrompts.bell.message.unsubscribing, "dialog.main.title": i.config.staticPrompts.bell.dialog.main.title, "dialog.main.button.subscribe": i.config.staticPrompts.bell.dialog.main.subscribeButton, "dialog.main.button.unsubscribe": i.config.staticPrompts.bell.dialog.main.unsubscribeButton, "dialog.blocked.title": i.config.staticPrompts.bell.dialog.blocked.title, "dialog.blocked.message": i.config.staticPrompts.bell.dialog.blocked.message } }, persistNotification: i.config.notificationBehavior ? i.config.notificationBehavior.display.persist : void 0, webhooks: { cors: i.config.webhooks.corsEnable, "notification.willDisplay": i.config.webhooks.notificationDisplayedHook, "notification.clicked": i.config.webhooks.notificationClickedHook, "notification.dismissed": i.config.webhooks.notificationDismissedHook }, notificationClickHandlerMatch: i.config.notificationBehavior ? i.config.notificationBehavior.click.match : void 0, notificationClickHandlerAction: i.config.notificationBehavior ? i.config.notificationBehavior.click.action : void 0, outcomes: { direct: i.config.outcomes.direct, indirect: { enabled: i.config.outcomes.indirect.enabled, influencedTimePeriodMin: i.config.outcomes.indirect.notification_attribution.minutes_since_displayed, influencedNotificationsLimit: i.config.outcomes.indirect.notification_attribution.limit }, unattributed: i.config.outcomes.unattributed } } } case 1: { const o = { scope: "/" }, c = { ...t, promptOptions: this.injectDefaultsIntoPromptOptions(t.promptOptions, i.config.staticPrompts, t), serviceWorkerParam: t.serviceWorkerParam ? t.serviceWorkerParam : o, serviceWorkerPath: t.serviceWorkerPath ? t.serviceWorkerPath : "OneSignalSDKWorker.js", path: t.path ? t.path : "/", outcomes: { direct: i.config.outcomes.direct, indirect: { enabled: i.config.outcomes.indirect.enabled, influencedTimePeriodMin: i.config.outcomes.indirect.notification_attribution.minutes_since_displayed, influencedNotificationsLimit: i.config.outcomes.indirect.notification_attribution.limit }, unattributed: i.config.outcomes.unattributed } }; return t.hasOwnProperty("autoResubscribe") ? c.autoResubscribe = !!t.autoResubscribe : t.hasOwnProperty("autoRegister") ? c.autoResubscribe = !!t.autoRegister : c.autoResubscribe = !!i.config.autoResubscribe, c } } } static hasUnsupportedSubdomainForConfigIntegrationKind(e, t, i) { switch (this.getIntegrationCapabilities(e).configuration) { case 0: return i.config.siteInfo.proxyOriginEnabled; case 1: return !!t.subdomainName } } } class Bt { static toOSNotification(e) { return { notificationId: e.custom.i, title: e.title, body: e.alert, additionalData: e.custom.a, launchURL: e.custom.u, confirmDelivery: e.custom.rr === "y", icon: e.icon, image: e.image, actionButtons: this.convertButtons(e.o), topic: e.tag, badgeIcon: e.badge } } static convertButtons(e) { return e?.map(t => ({ actionId: t.i, text: t.n, icon: t.p, launchURL: t.u })) } static isValid(e) { return typeof e?.custom?.i == "string" } } class Li { static async getPushSubscriptionIdByToken(e) { const t = await l.getAll(se.Subscriptions); for (const i of t) if (i.token === e) return i.id } } class Wi { static toNative(e) { return e?.map(t => ({ action: t.actionId, title: t.text, icon: t.icon })) } } class Vi { async send(e) { const t = await l.get("Options", `webhooks.${e.event}`); if (!t) return; const i = await l.get("Options", "webhooks.cors"), s = { method: "post", mode: "no-cors", body: JSON.stringify(e) }; i && (s.mode = "cors", s.headers = { "X-OneSignal-Event": e.event, "Content-Type": "application/json" }), h.debug(`Executing ${e.event} webhook ${i ? "with" : "without"} CORS POST ${t}`, e), await fetch(t, s) } } class Bi { event = "notification.clicked"; notificationId; heading; content; additionalData; actionId; url; subscriptionId; constructor(e, t) { const i = e.notification; this.notificationId = i.notificationId, this.heading = i.title, this.content = i.body, this.additionalData = i.additionalData, this.actionId = e.result.actionId, this.url = e.result.url, this.subscriptionId = t } } class Fi { event = "notification.willDisplay"; notificationId; heading; content; additionalData; actionId; url; subscriptionId; constructor(e, t) { this.notificationId = e.notificationId, this.heading = e.title, this.content = e.body, this.additionalData = e.additionalData, this.url = e.launchURL, this.subscriptionId = t } } class _i { event = "notification.dismissed"; notificationId; heading; content; additionalData; actionId; url; subscriptionId; constructor(e, t) { this.notificationId = e.notificationId, this.heading = e.title, this.content = e.body, this.additionalData = e.additionalData, this.url = e.launchURL, this.subscriptionId = t } } class $i { constructor(e = new Vi) { this.sender = e } async click(e, t) { return await this.sender.send(new Bi(e, t)) } async willDisplay(e, t) { return await this.sender.send(new Fi(e, t)) } async dismiss(e, t) { return await this.sender.send(new _i(e, t)) } } const ji = 25; class f { static get VERSION() { return v.version() } static get environment() { return v } static get log() { return h } static get database() { return l } static get webhookNotificationEventSender() { return new $i } static async getPushSubscriptionId() { const t = (await self.registration.pushManager.getSubscription())?.endpoint; if (t) return Li.getPushSubscriptionIdByToken(t) } static get workerMessenger() { return self.workerMessenger || (self.workerMessenger = new wt), self.workerMessenger } static run() { self.addEventListener("activate", f.onServiceWorkerActivated), self.addEventListener("push", f.onPushReceived), self.addEventListener("notificationclose", e => e.waitUntil(f.onNotificationClosed(e))), self.addEventListener("notificationclick", e => e.waitUntil(f.onNotificationClicked(e))), self.addEventListener("pushsubscriptionchange", e => { e.waitUntil(f.onPushSubscriptionChange(e)) }), self.addEventListener("message", e => { const t = e.data, i = t?.payload; switch (t?.command) { case P.SessionUpsert: h.debug("[Service Worker] Received SessionUpsert", i), f.debounceRefreshSession(e, i); break; case P.SessionDeactivate: h.debug("[Service Worker] Received SessionDeactivate", i), f.debounceRefreshSession(e, i); break; default: return } }), h.debug("Setting up message listeners."), setTimeout(() => { f.workerMessenger.listen(), f.setupMessageListeners() }, 0) } static async getAppId() { if (self.location.search) { const t = self.location.search.match(/appId=([0-9a-z-]+)&?/i); if (t && t.length > 1) return t[1] } const { appId: e } = await l.getAppConfig(); return e } static setupMessageListeners() { f.workerMessenger.on(P.WorkerVersion, () => { h.debug("[Service Worker] Received worker version message."), f.workerMessenger.broadcast(P.WorkerVersion, v.version()) }), f.workerMessenger.on(P.Subscribe, async e => { const t = e; h.debug("[Service Worker] Received subscribe message."); const i = new gt(t), s = await i.subscriptionManager.subscribe(we.ResubscribeExisting), o = await i.subscriptionManager.registerSubscription(s); f.workerMessenger.broadcast(P.Subscribe, o.serialize()) }), f.workerMessenger.on(P.SubscribeNew, async e => { const t = e; h.debug("[Service Worker] Received subscribe new message."); const i = new gt(t), s = await i.subscriptionManager.subscribe(we.SubscribeNew), o = await i.subscriptionManager.registerSubscription(s); f.workerMessenger.broadcast(P.SubscribeNew, o.serialize()) }), f.workerMessenger.on(P.AreYouVisibleResponse, async e => { h.debug("[Service Worker] Received response for AreYouVisible", e); const t = e.timestamp; self.clientsStatus?.timestamp === t && (self.clientsStatus.receivedResponsesCount++, e.focused && (self.clientsStatus.hasAnyActiveSessions = !0)) }), f.workerMessenger.on(P.SetLogging, async e => { e.shouldLog ? self.shouldLog = !0 : self.shouldLog = void 0 }) } static onPushReceived(e) { h.debug(`Called onPushReceived(${JSON.stringify(e, null, 4)}):`, e), e.waitUntil(f.parseOrFetchNotifications(e).then(async t => { const i = [], s = [], o = await f.getAppId(); for (const r of t) { h.debug("Raw Notification from OneSignal:", r); const c = Bt.toOSNotification(r); s.push(l.putNotificationReceivedForOutcomes(o, c)), i.push((async g => { const u = { notification: g }; await f.workerMessenger.broadcast(P.NotificationWillDisplay, u).catch(m => h.error(m)); const p = await f.getPushSubscriptionId(); return f.webhookNotificationEventSender.willDisplay(g, p), f.displayNotification(g).then(() => f.sendConfirmedDelivery(g)).catch(m => h.error(m)) }).bind(null, c)) } return i.reduce((r, c) => r = r.then(c), Promise.resolve()) }).catch(t => { h.debug("Failed to display a notification:", t) })) } static async sendConfirmedDelivery(e) { if (!e) return; if (!f.browserSupportsConfirmedDelivery()) return null; if (!e.confirmDelivery) return; const t = await f.getAppId(), i = await this.getPushSubscriptionId(); if (!!!(t && e.notificationId)) return; const o = { player_id: i, app_id: t, device_type: N.getDeviceType() }; h.debug(`Called sendConfirmedDelivery(${JSON.stringify(e, null, 4)})`), await ct(Math.floor(Math.random() * ji * 1e3)), await O.put(`notifications/${e.notificationId}/report_received`, o) } static browserSupportsConfirmedDelivery() { return R().name !== "safari" } static async getWindowClients() { return await self.clients.matchAll({ type: "window", includeUncontrolled: !0 }) } static async updateSessionBasedOnHasActive(e, t, i) { if (t) await L.upsertSession(i.appId, i.onesignalId, i.subscriptionId, i.sessionThreshold, i.enableSessionDuration, i.sessionOrigin, i.outcomesConfig); else { const s = await L.deactivateSession(i.appId, i.onesignalId, i.subscriptionId, i.sessionThreshold, i.enableSessionDuration, i.outcomesConfig); s && (self.cancel = s.cancel, e.waitUntil(s.promise)) } } static async refreshSession(e, t) { h.debug("[Service Worker] refreshSession"); const i = await this.getWindowClients(); if (t.isSafari) await f.checkIfAnyClientsFocusedAndUpdateSession(e, i, t); else { const s = i.some(o => o.focused); h.debug("[Service Worker] hasAnyActiveSessions", s), await f.updateSessionBasedOnHasActive(e, s, t) } } static async checkIfAnyClientsFocusedAndUpdateSession(e, t, i) { const s = new Date().getTime(); self.clientsStatus = { timestamp: s, sentRequestsCount: 0, receivedResponsesCount: 0, hasAnyActiveSessions: !1 }; const o = { timestamp: s }; t.forEach(g => { self.clientsStatus.sentRequestsCount++, g.postMessage({ command: P.AreYouVisible, payload: o }) }); const c = Ve(async () => { h.debug("updateSessionBasedOnHasActive", self.clientsStatus), await f.updateSessionBasedOnHasActive(e, self.clientsStatus.hasAnyActiveSessions, i), self.clientsStatus = void 0 }, .5); self.cancel = c.cancel, e.waitUntil(c.promise) } static debounceRefreshSession(e, t) { h.debug("[Service Worker] debounceRefreshSession", t), self.cancel && (self.cancel(), self.cancel = void 0); const s = Ve(async () => { await f.refreshSession(e, t) }, 1); self.cancel = s.cancel, e.waitUntil(s.promise) } static ensureImageResourceHttps(e) { if (e) try { const t = new URL(e); return t.hostname === "localhost" || t.hostname.indexOf("192.168") !== -1 || t.hostname === "127.0.0.1" || t.protocol === "https:" ? e : t.hostname === "i0.wp.com" || t.hostname === "i1.wp.com" || t.hostname === "i2.wp.com" || t.hostname === "i3.wp.com" ? `https://${t.hostname}${t.pathname}` : `https://i0.wp.com/${t.host + t.pathname}` } catch (t) { h.error("ensureImageResourceHttps: ", t) } } static ensureNotificationResourcesHttps(e) { if (e && (e.icon && (e.icon = f.ensureImageResourceHttps(e.icon)), e.image && (e.image = f.ensureImageResourceHttps(e.image)), e.actionButtons && e.actionButtons.length > 0)) for (const t of e.actionButtons) t.icon && (t.icon = f.ensureImageResourceHttps(t.icon)) } static async displayNotification(e) { h.debug(`Called displayNotification(${JSON.stringify(e, null, 4)}):`, e); const t = await f._getTitle(), i = await l.get("Options", "defaultIcon"), s = await l.get("Options", "persistNotification"), o = await f.getAppId(); e.title = e.title ? e.title : t, e.icon = e.icon ? e.icon : i || void 0, f.ensureNotificationResourcesHttps(e); const r = { body: e.body, icon: e.icon, image: e.image, data: e, actions: Wi.toNative(e.actionButtons), tag: e.topic || o, requireInteraction: s !== !1, renotify: !0, badge: e.badgeIcon }; await self.registration.showNotification(e.title, r), this.requiresMacOS15ChromiumAfterDisplayWorkaround() && await ct(1e3) } static requiresMacOS15ChromiumAfterDisplayWorkaround() { const e = navigator.userAgentData, t = e?.platform === "macOS", i = !!e?.brands?.some(s => s.brand === "Chromium"); return t && i } static shouldOpenNotificationUrl(e) { return e !== "javascript:void(0);" && e !== "do_not_open" && !b.contains(e, "_osp=do_not_open") } static async onNotificationClosed(e) { h.debug(`Called onNotificationClosed(${JSON.stringify(e, null, 4)}):`, e); const t = e.notification.data; f.workerMessenger.broadcast(P.NotificationDismissed, t).catch(s => h.error(s)); const i = await f.getPushSubscriptionId(); f.webhookNotificationEventSender.dismiss(t, i) } static async getNotificationUrlToOpen(e, t) { if (t) { const s = e?.actionButtons?.find(o => o.actionId === t); if (s?.launchURL && s.launchURL !== "") return s.launchURL } if (e.launchURL && e.launchURL !== "") return e.launchURL; const { defaultNotificationUrl: i } = await l.getAppState(); return i || location.origin } static async onNotificationClicked(e) { h.debug(`Called onNotificationClicked(${JSON.stringify(e, null, 4)}):`, e), e.notification.close(); const t = e.notification.data; let i = "exact", s = "navigate"; const o = await l.get("Options", "notificationClickHandlerMatch"); o && (i = o); const r = await this.database.get("Options", "notificationClickHandlerAction"); r && (s = r); const c = await f.getNotificationUrlToOpen(t, e.action), g = f.shouldOpenNotificationUrl(c), u = await f.getAppId(), p = N.getDeviceType(), m = { notification: t, result: { actionId: e.action, url: c }, timestamp: new Date().getTime() }; h.info("NotificationClicked", m); const y = (async E => { try { const W = await l.getCurrentSession(); if (W && W.status === le.Active) return; await l.putNotificationClickedForOutcomes(u, E), W && (W.notificationId = E.notification.notificationId, await l.upsertSession(W)) } catch (W) { h.error("Failed to save clicked notification.", W) } })(m), T = await this.getPushSubscriptionId(), C = f.sendConvertedAPIRequests(u, T, m, p), ze = await f.getWindowClients(); let qe = !1; for (const E of ze) { const W = E.url; let ye = ""; try { ye = new URL(W).origin } catch ($) { h.error("Failed to get the HTTP site's actual origin:", $) } let Oe = null; try { Oe = new URL(c).origin } catch ($) { h.error("Failed parse launchUrl:", $) } if (i === "exact" && W === c || i === "origin" && ye === Oe) { if (E.url === c || s === "focus" && ye === Oe) { f.workerMessenger.unicast(P.NotificationClicked, m, E); try { E instanceof WindowClient && await E.focus() } catch ($) { h.error("Failed to focus:", E, $) } } else if (E instanceof WindowClient && E.navigate) { try { h.debug("Client is standard HTTPS site. Attempting to focus() client."), E instanceof WindowClient && await E.focus() } catch ($) { h.error("Failed to focus:", E, $) } try { g ? (h.debug(`Redirecting HTTPS site to (${c}).`), await l.putNotificationClickedEventPendingUrlOpening(m), await E.navigate(c)) : h.debug("Not navigating because link is special.") } catch ($) { h.error("Failed to navigate:", E, c, $) } } else await l.putNotificationClickedEventPendingUrlOpening(m), await f.openUrl(c); qe = !0; break } } return g && !qe && (await l.putNotificationClickedEventPendingUrlOpening(m), await f.openUrl(c)), y && await y, await C } static async sendConvertedAPIRequests(e, t, i, s) { const o = i.notification; if (!o.notificationId) { console.error("No notification id, skipping networks calls to report open!"); return } let r; e ? r = O.put(`notifications/${o.notificationId}`, { app_id: e, player_id: t, opened: !0, device_type: s }) : console.error("No app Id, skipping OneSignal API call for notification open!"), await f.webhookNotificationEventSender.click(i, t), r && await r } static async openUrl(e) { h.debug("Opening notification URL:", e); try { return await self.clients.openWindow(e) } catch (t) { return h.warn(`Failed to open the URL '${e}':`, t), null } } static onServiceWorkerActivated(e) { h.info(`OneSignal Service Worker activated (version ${v.version()})`), e.waitUntil(self.clients.claim()) } static async onPushSubscriptionChange(e) { h.debug(`Called onPushSubscriptionChange(${JSON.stringify(e, null, 4)}):`, e); const t = await f.getAppId(); if (!t) return; const i = await Ri.getAppConfig({ appId: t }, $e.downloadServerAppConfig); if (!i) return; const s = new gt(i); let o; { let u = (await l.getSubscription()).deviceId; if (o = !!u, !o && e.oldSubscription) { u = await $e.getUserIdFromSubscriptionIdentifier(t, N.getDeviceType(), e.oldSubscription.endpoint); const p = await l.getSubscription(); p.deviceId = u, await l.setSubscription(p) } o = !!u } let r; const c = e.newSubscription; if (c) r = ae.setFromW3cSubscription(c); else try { r = await s.subscriptionManager.subscribe(we.SubscribeNew) } catch { } if (!o && !!!r) await l.remove("Ids", "userId"), await l.remove("Ids", "registrationId"); else { let u = null; Notification.permission !== "granted" ? u = F.PermissionRevoked : r || (u = F.PushSubscriptionRevoked), await s.subscriptionManager.registerSubscription(r, u) } } static _getTitle() { return new Promise(e => { Promise.all([l.get("Options", "defaultTitle"), l.get("Options", "pageTitle")]).then(([t, i]) => { t !== null ? e(t) : i != null ? e(i) : e("") }) }) } static parseOrFetchNotifications(e) { if (!e || !e.data) return Promise.reject("Missing event.data on push payload!"); if (f.isValidPushPayload(e.data)) { h.debug("Received a valid encrypted push payload."); const i = e.data.json(); return Promise.resolve([i]) } return Promise.reject(`Unexpected push message payload received: ${e.data}`) } static isValidPushPayload(e) { try { const t = e.json(); return Bt.isValid(t) ? !0 : (h.debug("isValidPushPayload: Valid JSON but missing notification UUID:", t), !1) } catch (t) { return h.debug("isValidPushPayload: Parsing to JSON failed with:", t), !1 } } } typeof self > "u" && typeof global < "u" ? global.OneSignalWorker = f : self.OneSignalWorker = f, typeof self < "u" && f.run(), self.OneSignal = f
})();
//# sourceMappingURL=OneSignalSDK.sw.js.map